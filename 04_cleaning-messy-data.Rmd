Cleaning Messy Data
===================

By now, we've learned all of the basic skills necessary to explore a data set
in R. This final chapter is a collection of different topics relevant to
cleaning data sets before and during analysis. Some of them, like loops, also
have other applications.


Loops
-----

One major benefit of using a programming language like R is that repetitive
tasks can be automated. We've already seen two ways to do this:

1. Vectorization, introduced in Section \@ref(vectorization)

2. Apply functions, introduced in Section \@ref(apply-functions)

Both of these are _iteration strategies_. They _iterate_ over some object, and
compute something for each element. Each one of these computations is one
_iteration_. Vectorization is the most efficient iteration strategy, but only
works with vectorized functions and vectors. Apply functions are more
flexible---they work with any function and any data structure with
elements---but less efficient and less concise.

A _loop_ is another iteration strategy, one that's even more flexible than
apply functions. Besides being flexible, loops are a feature of almost all
modern programming languages, so it's useful to understand them. In R, there
are two kinds of loops. We'll learn both.

### For-loops

A _for-loop_ runs a block of code once for each element of a vector or list.
The `for` keyword creates a for-loop. Here's the syntax:

```
for (I in DATA) {
  # Your code goes here
}
```

The variable `I` is called the _induction variable_. At the beginning of each
iteration, `I` is assigned the next element of the vector or list `DATA`. The
loop iterates once for each element of `DATA`, unless you use a keyword to exit
the loop early (more about this in Section \@ref(break-next)). As with
if-statements and functions, the curly braces `{ }` are only required if the
body contains multiple lines of code.

Unlike the other iteration strategies, loops do not automatically return a
result. You have complete control over the output, which means that anything
you want to save must be assigned to a variable.

For example, let's make a loop that repeatedly adds a number to a running total
and squares the new total. We'll use a variable `total` to keep track of the
running total as the loop iterates:

```{r}
numbers = c(-1, 1, -3, 2)

total = 0
for (number in numbers) {
  total = (total + number)^2
}

total
```

Use for-loops when some or all of the iterations depend on results from other
iterations. If the iterations are not dependent, use one of:

1. Vectorization (because it's faster)
2. Apply functions (because they're idiomatic)

In some cases, you can use vectorization even when the iterations are
dependent. For example, you can use vectorization to compute the sum of the
cubes of several numbers:

```{r}
sum(numbers^3)
```

### While-loops

A _while-loop_ runs a block of code repeatedly as long as some condition is
`TRUE`. The `while` keyword creates a while-loop. Here's the syntax:

```
while (CONDITION) {
  # Your code goes here
}
```

The `CONDITION` should be a scalar logical value or an expression that returns
one. At the beginning of each iteration, `CONDITION` is checked, and the loop
exits if it is `FALSE`. As always, the curly braces `{ }` are only required if
the body contains multiple lines of code.

For example, suppose you want to add up numbers from 0 to 50, but stop as soon
as the total is greater than 50:

```{r}
num50 = seq(0, 50)

total = 0
i = 1
while (total < 50) {
  total = total + num50[i]
  message("i is ", i, " total is ", total)
  i = i + 1
}

total
i
```

While-loops are a generalization of for-loops. They tend to be most useful when
you don't know how many iterations will be necessary. For example, suppose you
want to repeat a computation until the result falls within some range of
values.


### Saving Multiple Results

Loops often produce a different result for each iteration. If you want to save
more than one result, there are a few things you must do.

First, set up an index vector. The index vector should usually be congruent to
the number of iterations or the input. The `seq_along` function returns a
congruent index vector when passed a vector or list. For instance, let's make
in index for the `numbers` vector from Section \@ref(for-loops):

```{r}
index = seq_along(numbers)
```

The loop will iterate over the index rather than the input, so the induction
variable will track the current iteration number. On the first iteration, the
induction variable will be 1, on the second it will be 2, and so on. Then you
can use the induction variable and indexing to get the input for each
iteration.

Second, set up an empty output vector or list. This should usually be congruent
to the input, or one element longer (the extra element comes from the initial
value). R has several functions for creating vectors. We've already seen a few,
but here are more:

* `logical`, `integer`, `numeric`, `complex`, and `character` to create an
  empty vector with a specific type and length

* `vector` to create an empty vector with a specific type and length

* `rep` to create a vector by repeating elements of some other vector

Empty vectors are filled with `FALSE`, `0`, or `""`, depending on the type of
the vector. Here are some examples:

```{r}
logical(3)
numeric(4)
rep(c(1, 2), 2)
```

Let's create an empty numeric vector congruent to `numbers`:

```{r}
n = length(numbers)
result = numeric(n)
```

As with the input, you can use the induction variable and indexing to set the
output for each iteration.

Creating a vector or list in advance to store something, as we've just done, is
called _preallocation_. Preallocation is extremely important for efficiency in
loops. Avoid the temptation to use `c` or `append` to build up the output bit
by bit in each iteration.

Finally, write the loop, making sure to get the input and set the output.
Here's the loop for the squared sums example:

```{r}
for (i in index) {
  prev = if (i > 1) result[i - 1] else 0
  result[i] = (numbers[i] + prev)^2
}
result
```


### Break & Next

The `break` keyword causes a loop to immediately exit. It only makes sense to
use `break` inside of an if-statement.

For example, suppose we want to print each string in a vector, but stop at the
first missing value. We can do this with `break`:

```{r}
my_messages = c("Hi", "Hello", NA, "Goodbye")

for (msg in my_messages) {
  if (is.na(msg))
    break

  message(msg)
}
```

The `next` keyword causes a loop to immediately go to the next iteration. As
with `break`, it only makes sense to use `next` inside of an if-statement.

Let's modify the previous example so that missing values are skipped, but don't
cause printing to stop. Here's the code:

```{r}
for (msg in my_messages) {
  if (is.na(msg))
    next

  message(msg)
}
```

These keywords work with both for-loops and while-loops.


### Example: Fibonacci


As a final example, let's use a loop to compute Fibonacci numbers. Each
Fibonacci number is the sum of the previous two. The first few Fibonacci
numbers are:

```
1 1 2 3 5 8 13
```

We can use a loop to compute the first `n` Fibonacci numbers. Make sure to
choose an appropriate index and to preallocate for the output:

```{r}
n = 10
fib = c(1, 1, numeric(n - 2))

for (i in 3:n) {
  fib[i] = fib[i - 1] + fib[i - 2]
}

fib
```

If you want to reuse this code, you could make it a function:

```{r}
fibonacci = function(n = 10) {
  fib = c(1, 1, numeric(n - 2))

  for (i in 3:n) {
    fib[i] = fib[i - 1] + fib[i - 2]
  }

  fib
}

fibonacci(30)
```



Planning for Iteration
----------------------

At first it may seem difficult to decide if and what kind of iteration to use.
Start by thinking about whether you need to do something over and over. If you
don't, then you probably don't need to use iteration. If you do, then try
iteration strategies in this order:

1. vectorization
2. apply functions
    * Try an apply function if iterations are independent.
3. for/while-loops
    * Try a for-loop if some iterations depend on others.
    * Try a while-loop if the number of iterations is unknown.
4. recursion (which isn't covered here)
    * Convenient for naturally recursive problems (like Fibonacci),
      but often there are faster solutions.


Start by writing the code for just one iteration. Make sure that code works;
it's easy to test code for one iteration.

When you have one iteration working, then try using the code with an iteration
strategy (you will have to make some small changes). If it doesn't work, try to
figure out which iteration is causing the problem. One way to do this is to use
`message` to print out information. Then try to write the code for the broken
iteration, get that iteration working, and repeat this whole process.


String Processing
-----------------

So far, we've mostly worked with numbers or categories that are ready to use
for data analysis. In practice, data sets often require some cleaning before or
during data analysis. One common data cleaning task is editing or extracting
parts of strings.

We'll use the stringr package to process strings. Like ggplot2 (Section
\@ref(data-visualization)), the package is part of the [Tidyverse][tidy]. R
also has built-in functions for string processing. The main advantage of
stringr is that its functions use a common set of parameters, so they're easier
to learn and remember.

stringr has detailed [documentation][stringr-docs] and also a
[cheatsheet][stringr-cheat-sheet].

[stringr-docs]: https://stringr.tidyverse.org/
[stringr-cheat-sheet]: https://github.com/rstudio/cheatsheets/blob/master/strings.pdf
[tidy]: https://www.tidyverse.org/

The first time you use stringr, you'll have to install it with
`install.packages` (the same as any other package). Then you can load the
package with the `library` function:

```{r}
# install.packages("stringr")
library(stringr)
```

The typical syntax of a stringr function is:

```
str_NAME(string, pattern, ...)
```

Where:

* `NAME` describes what the function does
* `string` is the string to search within or transform
* `pattern` is the pattern to search for
* `...` is additional, function-specific arguments

The `str_detect` function detects whether the pattern appears within the
string. Here's an example:

```{r}
str_detect("hello", "el")

str_detect("hello", "ol")
```

Most of the stringr functions are vectorized in the `string` parameter. For
instance:

```{r}
str_detect(c("hello", "goodbye", "lo"), "lo")
```

Most of the stringr functions also have support for [_regular
expressions_][regex], a powerful language for describing  patterns. Several
punctuation characters, such as `.` and `?` have special meanings in the
regular expressions language. You can disable these special meanings by putting
the pattern in a call to `fixed`:

```{r}
str_detect("a", ".")
str_detect("a", fixed("."))
```

You can learn more about regular expressions [here][regex-r4ds].

[regex]: https://en.wikipedia.org/wiki/Regular_expression
[regex-r4ds]: https://r4ds.had.co.nz/strings.html#matching-patterns-with-regular-expressions


There are a lot of stringr functions. We'll focus on two that are especially
important, and some of their variants:

* `str_split`
* `str_replace`
 
You can find a complete list of stringr functions, with examples, in the
documentation.

### Splitting Strings

The `str_split` function splits the string at each position that matches the
pattern. The characters that match are thrown away.

For example, suppose we want to split a sentence into words. Since there's a
space between each word, we can use a space as the pattern:
```{r}
x = "The students in this workshop are great!"

result = str_split(x, " ")
result
```

The `str_split` function always returns a list with one element for each input
string. Here the list only has one element because `x` only has one element. We
can get the first element with:
```{r}
result[[1]]
```

We have to use the extraction operator `[[` here because `x` is a list (for a
vector, we could use the indexing operator `[` instead). Notice that in the
printout for `result`, R gives us a hint that we should use `[[` by printing
`[[1]]`.

To see why the function returns a list, consider what happens if we try to
split two different sentences at once:

```{r}
x = c(x, "Are you listening?")

result = str_split(x, " ")
result[[1]]
result[[2]]
```

Each sentence has a different number of words, so the vectors in the result
have different lengths. So a list is the only way to store both.

The `str_split_fixed` function is almost the same as `str_split`, but takes a
third argument for the maximum number of splits to make. Because the number of
splits is fixed, the function can return the result in a matrix instead of a
list. For example:

```{r}
str_split_fixed(x, " ", 3)
```

The `str_split_fixed` function is often more convenient than `str_split`
because the `n`th piece of each input string is just the `n`th column of the
result.

For example, suppose we want to get the area code from some phone numbers:

```{r}
phones = c("717-555-3421", "629-555-8902", "903-555-6781")
result = str_split_fixed(phones, "-", 3)

result[, 1]
```


### Replacing Parts of Strings

The `str_replace` function replaces the pattern the first time it appears in
the string. The replacement goes in the third argument.

For instance, suppose we want to change the word `"dog"` to `"cat"`:
```{r}
x = c("dogs are great, dogs are fun", "dogs are fluffy")
str_replace(x, "dog", "cat")
```


The `str_replace_all` function replaces the pattern every time it appears in
the string:
```{r}
str_replace_all(x, "dog", "cat")
```

We can also use the `str_replace` and `str_replace_all` functions to delete
part of a string by setting the replacement to the empty string `""`.

For example, suppose we want to delete the comma:
```{r}
str_replace(x, ",", "")
```

In general, stringr functions with the `_all` suffix affect all matches.
Functions without `_all` only affect the first match.



Date Processing
---------------

Besides strings, dates and times are another kind of data that require special
attention to prepare for analysis. This is especially important if you want to
do anything that involves sorting dates, like making a line plot with dates on
one axis. Dates may not be sorted correctly if they haven't been converted to
one of R's date classes.

There several built-in functions and also many packages for date processing. As
with visualization and string processing, the Tidyverse packages have the best
combination of simple design and clear documentation. There are three Tidyverse
packages for processing dates and times:

* [lubridate][], the primary package for working with dates and times
* [hms][], a package specifically for working with times
* [clock][], a new package for working with dates and times

[lubridate]: https://lubridate.tidyverse.org/
[hms]: https://hms.tidyverse.org/
[clock]: https://clock.r-lib.org/

We'll focus on the lubridate package. As always, you'll have to install the
package if you haven't already, and then load it:

```{r}
# install.packages("lubridate")
library(lubridate)
```

The most common task is to convert a string into a date or time class. For
instance, when you load a data set, you might have dates that look like this:

```{r}
dates = c("Jan 10, 2021", "Sep 3, 2018", "Feb 28, 1982")
dates
```

These are strings, so it's relatively difficult to sort the dates, do
arithmetic on them, or extract just one part (such as the year). There are
several lubridate functions to automatically convert strings into dates. They
are named with one letter for each part of the date. For instance, the dates in
the example have the month (m), then the day (d), and then the year (y), so we
can use the `mdy` function:

```{r}
result = mdy(dates)
result
class(result)
```

Notice that the dates now have class `Date`, one of R's built-in classes for
representing dates, and that they print differently. You can find a full list
of the automatic string to date conversion functions in the lubridate
documentation.

Occasionally, a date string may have a format that lubridate can't convert
automatically. In that case, you can use the `fast_strptime` function to
describe the format in detail. At a minimum, the function requires two
arguments: the vector of strings to convert and a format string.

The format string describes the format of the dates, and is based on the syntax
of `strptime`, a function provided by many programming languages for converting
strings to dates (including R). In a format string, a percent sign `%` followed
by a character is called a _specification_ and has a special meaning. Here are
a few of the most useful ones:

| Specification | Description      | January 29, 2015
|:------------- |:---------------- |:----------------
| `%Y`          | 4-digit year     | 2015
| `%y`          | 2-digit year     | 15
| `%m`          | 2-digit month    | 01
| `%B`          | full month name  | January
| `%b`          | short month name | Jan
| `%d`          | day of month     | 29
| `%%`          | literal %        | %

You can find a complete list in `?fast_strptime`. Other characters in the
format string do not have any special meaning. Write the format string so that
it matches the format of the dates you want to convert.

For example, let's try converting an unusual time format:
```{r}
odd_time = "6 minutes, 32 seconds after 10 o'clock"
fast_strptime(odd_time, "%M minutes, %S seconds after %H o'clock")
```

R usually represents dates with the class `Date`, and date-times with the
classes `POSIXct` and `POSIXlt`. The difference between the two date-time
classes is somewhat technical, but you can read more about it in `?POSIXlt`.

There is no built-in class to represent times alone, which is why the result in
the example above includes a date. Nonetheless, the hms package provides the
`hms` class to represent times without dates.

Once you've converted a string to a date, the lubridate package provides a
variety of functions to get or set the parts individually. Here are a few
examples:

```{r}
day(result)
month(result)
```

You can find a complete list in the lubridate documentation.
