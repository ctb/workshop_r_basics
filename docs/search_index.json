[["index.html", "R Basics An Introduction to Programming for Researchers Overview", " R Basics An Introduction to Programming for Researchers Nick Ulle 2022-09-13 Overview This 4-part workshop series provides an introduction to using the R programming language for reproducible data analysis and scientific computing. Topics include programming basics, how to work with tabular data, how to break down programming problems, and how to organize code for clarity and reproducibility. After this workshop, learners will be able to load tabular data sets into R, compute simple summaries and visualizations, do common data-tidying tasks, write reusable functions, and identify where to go to learn more. No prior programming experience is necessary. All learners will need access to an internet-connected computer and the latest version of Zoom, R, and RStudio. "],["getting-started.html", "1 Getting Started 1.1 Prerequisites 1.2 The R Interface 1.3 Getting Help 1.4 File Systems 1.5 Reading Files 1.6 Data Frames 1.7 Exercises", " 1 Getting Started R is a program for statistical computing. It provides a rich set of built-in tools for cleaning, exploring, modeling, and visualizing data. The main way you’ll interact with R is by writing code or expressions in the R programming language. Most people use “R” as a blanket term to refer to both the program and the programming language. Usually, the distinction doesn’t matter, but in cases where it does, we’ll point it out and be specific. By writing code, you create an unambiguous record of every step taken in an analysis. This it one of the major advantages of R (and other programming languages) over point-and-click software like Tableau and Microsoft Excel. Code you write in R is reproducible: you can share it with someone else, and if they run it with the same inputs, they’ll get the same results. Another advantage of writing code is that it’s often reusable. This can mean automating a repetitive task within a single analysis, recycling code from one analysis into another, or packaging useful code for distribution to the general public. At the time of writing, there were over 17,000 user-contributed packages available for R, spanning a broad range of disciplines. R is one of many programming languages used in data science. Compared to other programming languages, R’s particular strengths are its interactivity, built-in support for handling missing data, the ease with which you can produce high-quality data visualizations, and its broad base of user-contributed packages (due to both its age and growing popularity). 1.1 Prerequisites You can download R for free here, and can find an install guide here. In addition to R, you’ll need RStudio. RStudio is an integrated development environment (IDE), which means it’s a comprehensive program for writing, editing, searching, and running code. You can do all of these things without RStudio, but RStudio makes the process easier. You can download RStudio Desktop Open-Source Edition for free here, and can find an install guide here. 1.2 The R Interface The first time you open RStudio, you’ll see a window divided into several panes, like this: Don’t worry if the text in the panes isn’t exactly the same on your computer; it depends on your operating system and versions of R and RStudio. The console pane, on the left, is the main interface to R. If you type R code into the console and press the Enter key on your keyboard, R will run your code and return the result. On the right are the environment pane and the plots pane. The environment pane shows data in your R workspace. The plots pane shows any plots you make, and also has tabs to browse your file system and to view R’s built-in help files. We’ll learn more about these gradually, but to get started we’ll focus on the console pane. Let’s start by using R to do some arithmetic. In the console, you’ll see that the cursor is on a line that begins with &gt;, called the prompt. You can make R compute the sum \\(2 + 2\\) by typing the code 2 + 2 after the prompt and then pressing the Enter key. Your code and the result from R should look like this: R always puts the result on a separate line (or lines) from your code. In this case, the result begins with the tag [1], which is a hint from R that the result is a vector and that this line starts with the element at position 1. We’ll learn more about vectors in Section 2.1, and eventually learn about other data types that are displayed differently. The result of the sum, 4, is displayed after the tag. In this reader, results from R will usually be typeset in monospace and further prefixed with ## to indicate that they aren’t code. If you enter an incomplete expression, R will change the prompt to +, then wait for you to type the rest of the expression and press the Enter key. Here’s what it looks like if you only enter 2 +: You can finish entering the expression, or you can cancel it by pressing the Esc key (or Ctrl-c if you’re using R without RStudio). R can only tell an expression is incomplete if it’s missing something, like the second operand in 2 +. So if you mean to enter 2 + 2 but accidentally enter 2, which is a complete expression by itself, don’t expect R to read your mind and wait for more input! Try out some other arithmetic in the R console. Besides + for addition, the other arithmetic operators are: - for subtraction * for multiplication / for division %% for remainder division (modulo) ^ or ** for exponentiation You can combine these and use parentheses to make more complicated expressions, just as you would when writing a mathematical expression. When R computes a result, it follows the standard order of operations: parentheses, exponentiation, multiplication, division, addition, and finally subtraction. For example, to estimate the area of a circle with radius 3, you can write: 3.14 * 3^2 ## [1] 28.26 You can write R expressions with any number of spaces (including none) around the operators and R will still compute the result. Nevertheless, putting spaces in your code makes it easier for you and others to read, so it’s good to make it a habit. Put spaces around most operators, after commas, and after keywords. 1.2.1 Variables Since R is designed for mathematics and statistics, you might expect that it provides a better appoximation for \\(\\pi\\) than 3.14. R and most other programming languages allow you to create named values, or variables. R provides a built-in variable called pi for the value of \\(\\pi\\). You can display a variable’s value by entering its name in the console: pi ## [1] 3.141593 You can also use variables in expressions. For instance, here’s a more precise expression for the area of a circle with radius 3: pi * 3^2 ## [1] 28.27433 You can define your own variables with the assignment operator = or &lt;-. In most circumstances these two operators are interchangeable. For clarity, it’s best to choose one you like and use it consistently in all of your R code. In this reader, we use = for assignment because this is the assignment operator in most programming languages. The main reason to use variables is to save results so that you can use them on other expressions later. For example, to save the area of the circle in a variable called area, we can write: area = pi * 3^2 In R, variable names can contain any combination of letters, numbers, dots ., and underscores _, but must always start with a letter or a dot. Spaces and other symbols are not allowed in variable names. Now we can use the area variable anywhere we want the computed area. Notice that when you assign a result to a variable, R doesn’t automatically display that result. If you want to see the result as well, you have to enter the variable’s name as a separate expression: area ## [1] 28.27433 Another reason to use variables is to make an expression more general. For instance, you might want to compute the area of several circles with different radii. Then the expression pi * 3^2 is too specific. You can rewrite it as pi * r^2, and then assign a value to the variable r just before you compute the area. Here’s the code to compute and display the area of a circle with radius 1 this way: r = 1 area = pi * r^2 area ## [1] 3.141593 Now if you want to compute the area for a different radius, all you have to do is change r and run the code again (R will not change area until you do this). Writing code that’s general enough to reuse across multiple problems can be a big time-saver in the long run. Later on, we’ll see ways to make this code even easier to reuse. 1.2.2 Strings R treats anything inside single or double quotes as literal text rather than as an expression to evaluate. In programming jargon, a piece of literal text is called a string. You can use whichever kind of quotes you prefer, but the quote at the beginning of the string must match the quote at the end. &#39;Hi&#39; ## [1] &quot;Hi&quot; &quot;Hello!&quot; ## [1] &quot;Hello!&quot; Numbers and strings are not the same thing, so for example R considers 1 different from \"1\". As a result, you can’t use strings with most of R’s arithmetic operators. For instance, this code causes an error: &quot;1&quot; + 3 ## Error in &quot;1&quot; + 3: non-numeric argument to binary operator The error message notes that + is not defined for non-numeric values. 1.2.3 Comparisons Besides arithmetic, you can also use R to compare values. The comparison operators are: &lt; for “less than” &gt; for “greater than” &lt;= for “less than or equal to” &gt;= for “greater than or equal to” == for “equal to” != for “not equal to” The “equal to” operator uses two equal signs so that R can distinguish it from =, the assignment operator. Let’s look at a few examples: 1.5 &lt; 3 ## [1] TRUE &quot;a&quot; &gt; &quot;b&quot; ## [1] FALSE pi == 3.14 ## [1] FALSE &quot;hi&quot; == &#39;hi&#39; ## [1] TRUE When you make a comparison, R returns a logical value, TRUE or FALSE, to indicate the result. Logical values are not the same as strings, so they are not quoted. Logical values are values, so you can use them in other computations. For example: TRUE ## [1] TRUE TRUE == FALSE ## [1] FALSE Section 2.4.5 describes more ways to use and combine logical values. Beware that the equality operators don’t always return FALSE when you compare two different types of data: &quot;1&quot; == 1 ## [1] TRUE &quot;TRUE&quot; &lt;= TRUE ## [1] TRUE &quot;FALSE&quot; &lt;= TRUE ## [1] TRUE Section 2.2.2 explains why this happens, and Appendix 5.1 explains several other ways to compare values. 1.2.4 Calling Functions Most of R’s features are provided through functions, pieces of reusable code. You can think of a function as a machine that takes some inputs and uses them to produce some output. In programming jargon, the inputs to a function are called arguments, the output is called the return value, and when we use a function, we say we’re calling the function. To call a function, write its name followed by parentheses. Put any arguments to the function inside the parentheses. For example, in R, the sine function is named sin (there are also cos and tan). So we can compute the sine of \\(\\pi / 4\\) with this code: sin(pi / 4) ## [1] 0.7071068 There are many functions that accept more than one argument. For instance, the sum function accepts any number of arguments and adds them all together. When you call a function with multiple arguments, separate the arguments with commas. So another way to compute \\(2 + 2\\) in R is: sum(2, 2) ## [1] 4 When you call a function, R assigns each argument to a parameter. Parameters are special variables that represent the inputs to a function and only exist while that function runs. For example, the log function, which computes a logarithm, has parameters x and base for the operand and base of the logaritm, respectively. The next section, Section 1.3, explains how to look up the parameters for a function. By default, R assigns arguments to parameters based on their order. The first argument is assigned to the function’s first parameter, the second to the second, and so on. So we can compute the logarithm of 64, base 2, with this code: log(64, 2) ## [1] 6 The argument 64 is assigned to the parameter x, and the argument 2 is assigned to the parameter base. You can also assign arguments to parameters by name with = (not &lt;-), overriding their positions. So some other ways we could write the call above are: log(64, base = 2) ## [1] 6 log(x = 64, base = 2) ## [1] 6 log(base = 2, x = 64) ## [1] 6 log(base = 2, 64) ## [1] 6 All of these are equivalent. When you write code, choose whatever seems the clearest to you. Leaving parameter names out of calls saves typing, but including some or all of them can make the code easier to understand. Parameters are not regular variables, and only exist while their associated function runs. You can’t set them before a call, nor can you access them after a call. So this code causes an error: x = 64 log(base = 2) ## Error in eval(expr, envir, enclos): argument &quot;x&quot; is missing, with no default In the error message, R says that we forgot to assign an argument to the parameter x. We can keep the variable x and correct the call by making x an argument (for the parameter x): log(x, base = 2) ## [1] 6 Or, written more explicitly: log(x = x, base = 2) ## [1] 6 In summary, variables and parameters are distinct, even if they happen to have the same name. The variable x is not the same thing as the parameter x. 1.3 Getting Help Learning and using a language is hard, so it’s important to know how to get help. The first place to look for help is R’s built-in documentation. In the console, you can access a specific help page by name with ? followed by the name of the page. There are help pages for all of R’s built-in functions, usually with the same name as the function itself. So the code to open the help page for the log function is: ?log For functions, help pages usually include a brief description, a list of parameters, a description of the return value, and some examples. There are also help pages for other topics, such as built-in mathematical constants (such as ?pi), data sets (such as ?iris), and operators. To look up the help page for an operator, put the operator’s name in single or double quotes. For example, this code opens the help page for the arithmetic operators: ?&quot;+&quot; It’s always okay to put quotes around the name of the page when you use ?, but they’re only required if it contains non-alphabetic characters. So ?sqrt, ?'sqrt', and ?\"sqrt\" all open the documentation for sqrt, the square root function. Sometimes you might not know the name of the help page you want to look up. You can do a general search of R’s help pages with ?? followed by a string of search terms. For example, to get a list of all help pages related to linear models: ??&quot;linear model&quot; This search function doesn’t always work well, and it’s often more efficient to use an online search engine. When you search for help with R online, include “R” as a search term. Alternatively, you can use RSeek, which restricts the search to a selection of R-related websites. 1.3.1 When Something Goes Wrong As a programmer, sooner or later you’ll run some code and get an error message or result you didn’t expect. Don’t panic! Even experienced programmers make mistakes regularly, so learning how to diagnose and fix problems is vital. Try going through these steps: If R returned a warning or error message, read it! If you’re not sure what the message means, try searching for it online. Check your code for typographical errors, including incorrect capitalization and missing or extra commas, quotes, and parentheses. Test your code one line at a time, starting from the beginning. After each line that assigns a variable, check that the value of the variable is what you expect. Try to determine the exact line where the problem originates (which may differ from the line that emits an error!). If none of these steps help, try asking online. Stack Overflow is a popular question and answer website for programmers. Before posting, make sure to read about how to ask a good question. 1.4 File Systems Most of the time, you won’t just write code directly into the R console. Reproducibility and reusability are important benefits of R over point-and-click software, and in order to realize these, you have to save your code to your computer’s hard drive. Let’s start by reviewing how files on a computer work. You’ll need to understand that before you can save your code, and it will also be important later on for loading data sets. Your computer’s file system is a collection of files (chunks of data) and directories (or “folders”) that organize those files. For instance, the file system on a computer shared by Ada and Charles, two pioneers of computing, might look like this: Don’t worry if your file system looks a bit different from the picture. File systems have a tree-like structure, with a top-level directory called the root directory. On Ada and Charles’ computer, the root is called /, which is also what it’s called on all macOS and Linux computers. On Windows, the root is usually called C:/, but sometimes other letters, like D:/, are also used depending on the computer’s hardware. A path is a list of directories that leads to a specific file or directory on a file system (imagine giving directons to someone as they walk through the file system). We use forward slashes / to separate the directories in a path, rather than commas or spaces. The root directory includes a forward slash as part of its name, and doesn’t need an extra one. For example, suppose Ada wants to write a path to the file cats.csv. She can write the path like this: /Users/ada/cats.csv You can read this path from left-to-right as, “Starting from the root directory, go to the Users directory, then from there go to the ada directory, and from there go to the file cats.csv.” Alternatively, you can read the path from right-to-left as, “The file cats.csv inside of the ada directory, which is inside of the Users directory, which is in the root directory.” As another example, suppose Charles wants a path to the Programs directory. He can write: /Programs/ The / at the end of this path is reminder that Programs is a directory, not a file. Charles could also write the path like this: /Programs This is still correct, but it’s not as obvious that Programs is a directory. In other words, when a path leads to a directory, including a trailing slash is optional, but makes the meaning of the path clearer. Paths that lead to files never have a trailing slash. On Windows computers, paths are usually written with backslashes \\ to separate directories instead of forward slashes. Fortunately, R uses forward slashes / for all paths, regardless of the operating system. So when you’re working in R, use forward slashes and don’t worry about the operating system. This is especially convenient when you want to share code with someone that uses a different operating system than you. 1.4.1 Absolute &amp; Relative Paths A path that starts from the root directory, like all of the ones we’ve seen so far, is called an absolute path. The path is “absolute” because it unambiguously describes where a file or directory is located. The downside is that absolute paths usually don’t work well if you share your code. For example, suppose Ada uses the path /Programs/ada/cats.csv to load the cats.csv file in her code. If she shares her code with another pioneer of computing, say Gladys, who also has a copy of cats.csv, it might not work. Even though Gladys has the file, she might not have it in a directory called ada, and might not even have a directory called ada on her computer. Because Ada used an absolute path, her code works on her own computer, but isn’t portable to others. On the other hand, a relative path is one that doesn’t start from the root directory. The path is “relative” to an unspecified starting point, which usually depends on the context. For instance, suppose Ada’s code is saved in the file analysis.R (more about .R files in Section 1.4.2), which is in the same directory as cats.csv on her computer. Then instead of an absolute path, she can use a relative path in her code: cats.csv The context is the location of analysis.R, the file that contains the code. In other words, the starting point on Ada’s computer is the ada directory. On other computers, the starting point will be different, depending on where the code is stored. Now suppose Ada sends her corrected code in analysis.R to Gladys, and tells Gladys to put it in the same directory as cats.csv. Since the path cats.csv is relative, the code will still work on Gladys’ computer, as long as the two files are in the same directory. The name of that directory and its location in the file system don’t matter, and don’t have to be the same as on Ada’s computer. Gladys can put the files in a directory /Users/gladys/from_ada/ and the path (and code) will still work. Relative paths can include directories. For example, suppose that Charles wants to write a relative path from the Users directory to a cool selfie he took. Then he can write: charles/cool_hair_selfie.jpg You can read this path as, “Starting from wherever you are, go to the charles directory, and from there go to the cool_hair_selfie.jpg file.” In other words, the relative path depends on the context of the code or program that uses it. When use you paths in R code, they should almost always be relative paths. This ensures that the code is portable to other computers, which is an important aspect of reproducibility. Another benefit is that relative paths tend to be shorter, making your code easier to read (and write). When you write paths, there are three shortcuts you can use. These are most useful in relative paths, but also work in absolute paths: . means the current directory. .. means the directory above the current directory. ~ means the home directory. Each user has their own home directory, whose location depends on the operating system and their username. Home directories are typically found inside C:/Users/ on Windows, /Users/ on macOS, and /home/ on Linux. As an example, suppose Ada wants to write a (relative) path from the ada directory to Charles’ cool selfie. Using these shorcuts, she can write: ../charles/cool_hair_selfie.jpg Read this as, “Starting from wherever you are, go up one directory, then go to the charles directory, and then go to the cool_hair_selfie.jpg file.” Since /Users/ada is Ada’s home directory, she could also write the path as: ~/../charles/cool_hair_selfie.jpg This path has the same effect, but the meaning is slightly different. You can read it as “Starting from your home directory, go up one directory, then go to the charles directory, and then go to the cool_hair_selfie.jpg file.” The .. and ~ shortcut are frequently used and worth remembering. The . shortcut is included here in case you see it in someone else’s code. Since it means the current directory, a path like ./cats.csv is identical to cats.csv, and the latter is preferable for being simpler. There are a few specific situations where . is necessary, but they fall outside the scope of this text. 1.4.2 R Scripts Now that you know how file systems and paths work, you’re ready to learn how to save your R code to a file. R code is usually saved into an R script (extension .R) or an R Markdown file (extension .Rmd). R scripts are slightly simpler, so let’s focus on those. In RStudio, you can create a new R script with this menu option: File -&gt; New File -&gt; R Script This will open a new pane in RStudio, like this: The new pane is the scripts pane, which displays all of the R scripts you’re editing. Each script appears in a separate tab. In the screenshot, only one script, the new script, is open. Editing a script is similar to editing any other text document. You can write, delete, copy, cut, and paste text. You can also save the file to your computer’s file system. When you do, pay attention to where you save the file, as you might need it later. The contents of an R script should be R code. Anything else you want to write in the script (notes, documentation, etc.) should be in a comment. In R, comments begin with # and extend to the end of the line: # This is a comment. R will ignore comments when you run your code. When you start a new project, it’s a good idea to create a specific directory for all of the project’s files. If you’re using R, you should also create one or more R scripts in that directory. As you work, write your code directly into a script. Arrange your code in the order of the steps to solve the problem, even if you write some parts before others. Comment out or delete any lines of code that you try but ultimately decide you don’t need. Make sure to save the file periodically so that you don’t lose your work. Following these guidelines will help you stay organized and make it easier to share your code with others later. While editing, you can run the current line in the R console by pressing Ctrl+Enter on Windows and Linux, or Cmd+Enter on macOS. This way you can test and correct your code as you write it. If you want, you can instead run (or source) the entire R script, by calling the source function with the path to the script as an argument. This is also what the “Source on Save” check box refers to in RStudio. The code runs in order, only stopping if an error occurs. For instance, if you save the script as my_cool_script.R, then you can run source(\"my_cool_script.R\") in the console to run the entire script (pay attention to the path—it may be different on your computer). R Markdown files are an alternative format for storing R code. They provide a richer set of formatting options, and are usually a better choice than R scripts if you’re writing a report that contains code. You can learn more about R Markdown files here. 1.4.3 The Working Directory Section 1.4.1 explained that relative paths have a starting point that depends on the context where the path is used. We can make that idea more concrete for R. The working directory is the starting point R uses for relative paths. Think of the working directory as the directory R is currently “at” or watching. The function getwd returns the absolute path for the current working directory, as a string. It doesn’t require any arguments: getwd() ## [1] &quot;/home/nick/workshop/datalab/workshops/r_basics&quot; On your computer, the output from getwd will likely be different. This is a very useful function for getting your bearings when you write relative paths. If you write a relative path and it doesn’t work as expected, the first thing to do is check the working directory. The related setwd function changes the working directory. It takes one argument: a path to the new working directory. Here’s an example: setwd(&quot;..&quot;) # Now check the working directory. getwd() ## [1] &quot;/home/nick/workshop/datalab/workshops&quot; Generally, you should avoid using calls to setwd in your R scripts and R Markdown files. Calling setwd makes your code more difficult to understand, and can always be avoided by using appropriate relative paths. If you call setwd with an absolute path, it also makes your code less portable to other computers. It’s fine to use setwd interactively (in the R console), but avoid making your saved code dependent on it. Another function that’s useful for dealing with the working directory and file system is list.files. The list.files function returns the names of all of the files and directories inside of a directory. It accepts a path to a directory as an argument, or assumes the working directory if you don’t pass a path. For instance: # List files and directories in /home/. list.files(&quot;/home/&quot;) ## [1] &quot;lost+found&quot; &quot;nick&quot; # List files and directories in the working directory. list.files() ## [1] &quot;_bookdown_files&quot; &quot;_bookdown.yml&quot; ## [3] &quot;_main.rds&quot; &quot;01_getting-started.Rmd&quot; ## [5] &quot;02_data-structures.Rmd&quot; &quot;03_exploring-data_files&quot; ## [7] &quot;03_exploring-data.Rmd&quot; &quot;04_automating-tasks.Rmd&quot; ## [9] &quot;96_appendix.Rmd&quot; &quot;97_where-to-learn-more.Rmd&quot; ## [11] &quot;98_acknowledgements.Rmd&quot; &quot;99_assessment.Rmd&quot; ## [13] &quot;data&quot; &quot;docs&quot; ## [15] &quot;graphviz&quot; &quot;img&quot; ## [17] &quot;index.md&quot; &quot;index.Rmd&quot; ## [19] &quot;knit.R&quot; &quot;LICENSE&quot; ## [21] &quot;makefile&quot; &quot;raw&quot; ## [23] &quot;README.md&quot; &quot;render1fdc3c9871a0.rds&quot; ## [25] &quot;renv&quot; &quot;renv.lock&quot; As usual, since you have a different computer, you’re likely to see different output if you run this code. If you call list.files with an invalid path or an empty directory, the output is character(0): list.files(&quot;/this/path/is/fake/&quot;) ## character(0) Later on, we’ll learn about what character(0) means more generally. 1.5 Reading Files Analyzing data sets is one of the most common things to do in R. The first step is to get R to read your data. Data sets come in a variety of file formats, and you need to identify the format in order to tell R how to read the data. Most of the time, you can guess the format of a file by looking at its extension, the characters (usually three) after the last dot . in the filename. For example, the extension .jpg or .jpeg indicates a JPEG image file. Some operating systems hide extensions by default, but you can find instructions to change this setting online by searching for “show file extensions” and your operating system’s name. The extension is just part of the file’s name, so it should be taken as a hint about the file’s format rather than a guarantee. R has built-in functions for reading a variety of formats. The R community also provides packages, shareable and reusable pieces of code, to read even more formats. You’ll learn more about packages later, in Section 3.2. For now, let’s focus on data sets that can be read with R’s built-in functions. Here are several formats that are frequently used to distribute data, along with the name of a built-in function or contributed package that can read the format: Name Extension Function or Package Tabular? Text? Comma-separated Values .csv read.csv Yes Yes Tab-separated Values .tsv read.delim Yes Yes Fixed-width File .fwf read.fwf Yes Yes Microsoft Excel .xlsx readr package Yes No Microsoft Excel 1993-2007 .xls readr package Yes No Apache Arrow .feather arrow package Yes No R Data .rds readRDS Sometimes No R Data .rda load Sometimes No Plaintext .txt readLines Sometimes Yes Extensible Markup Language .xml xml2 package No Yes JavaScript Object Notation .json jsonlite package No Yes A tabular data set is one that’s structured as a table, with rows and columns. We’ll focus on tabular data sets for most of this reader, since they’re easier to get started with. Here’s an example of a tabular data set: Fruit Quantity Price apple 32 1.49 banana 541 0.79 pear 10 1.99 A text file is one that contains human-readable lines of text. You can check this by opening the file with a text editor such as Microsoft Notepad or macOS TextEdit. Many file formats use text in order to make the format easier to work with. For instance, a comma-separated values (CSV) file records a tabular data using one line per row, with commas separating columns. If you store the table above in a CSV file and open the file in a text editor, here’s what you’ll see: Fruit,Quantity,Price apple,32,1.49 banana,541,0.79 pear,10,1.99 A binary file is one that’s not human-readable. You can’t just read off the data if you open a binary file in a text editor, but they have a number of other advantages. Compared to text files, binary files are often faster to read and take up less storage space (bytes). As an example, R’s built-in binary format is called RDS (which may stand for “R data serialized”). RDS files are extremely useful for backing up work, since they can store any kind of R object, even ones that are not tabular. You can learn more about how to create an RDS file on the ?saveRDS help page, and how to read one on the ?readRDS help page. 1.5.1 Hello, Data! Let’s read our first data set! Over the next few sections, we’re going to explore data from the U.S. Bureau of Labor Statistics about median employee earnings. The data set was prepared as part of the Tidy Tuesday R community project. You can find more details about the data set here, and you can download the data set here (you may need to choose File -&gt; Save As... in your browser’s menu). The data set is a file called earn.csv, which suggests it’s a CSV file. In this case, the extension is correct, so we can read the file into R with the built-in read.csv function. The first argument is the path to where you saved the file, which may be different on your computer. The read.csv function returns the data set, but R won’t keep the data in memory unless we assign the returned result to a variable: earn = read.csv(&quot;data/earn.csv&quot;) The variable name earn here is arbitrary; you can choose something different if you want. However, in general, it’s a good habit to choose variable names that describe the contents of the variable somehow. If you tried running the line of code above and got an error message, pay attention to what the error message says, and remember the strategies to get help in Section 1.3. The most common mistake when reading a file is incorrectly specifying the path, so first check that you got the path right. If you ran the line of code and there was no error message, congratulations, you’ve read your first data set into R! 1.6 Data Frames Now that we’ve loaded the data, let’s take a look at it. When you’re working with a new data set, it’s usually not a good idea to print it out directly (by typing earn, in this case) until you know how big it is. Big data sets can take a long time to print, and the output can be difficult to read. Instead, you can use the head function to print only the beginning, or head, of a data set. Let’s take a peek: head(earn) ## sex race ethnic_origin age year quarter n_persons ## 1 Both Sexes All Races All Origins 16 years and over 2010 1 96821000 ## 2 Both Sexes All Races All Origins 16 years and over 2010 2 99798000 ## 3 Both Sexes All Races All Origins 16 years and over 2010 3 101385000 ## 4 Both Sexes All Races All Origins 16 years and over 2010 4 100120000 ## 5 Both Sexes All Races All Origins 16 years and over 2011 1 98329000 ## 6 Both Sexes All Races All Origins 16 years and over 2011 2 100593000 ## median_weekly_earn ## 1 754 ## 2 740 ## 3 740 ## 4 752 ## 5 755 ## 6 753 This data set is tabular—as you might have already guessed, since it came from a CSV file. In R, it’s represented by a data frame, a table with rows and columns. R uses data frames to represent most (but not all) kinds of tabular data. The read.csv function, which we used to read this data, always returns a data frame. For a data frame, the head function only prints the first six rows. If there are lots of columns or the columns are wide, as is the case here, R wraps the output across lines. When you first read an object into R, you might not know whether it’s a data frame. One way to check is visually, by printing it, as we just did. A better way to check is with the class function, which returns information about what an object is. For a data frame, the result will always contain data.frame: class(earn) ## [1] &quot;data.frame&quot; We’ll learn more about classes in Section 2.2, but for now you can use this function to identify data frames. By counting the columns in the output from head(earn), we can see that this data set has eight columns. A more convenient way to check the number of columns in a data set is with the ncol function: ncol(earn) ## [1] 8 The similarly-named nrow function returns the number of rows: nrow(earn) ## [1] 4224 Alternatively, you can get both numbers at the same time with the dim (short for “dimensions”) function. Since the columns have names, we might also want to get just these. You can do that with the names or colnames functions. Both return the same result: names(earn) ## [1] &quot;sex&quot; &quot;race&quot; &quot;ethnic_origin&quot; ## [4] &quot;age&quot; &quot;year&quot; &quot;quarter&quot; ## [7] &quot;n_persons&quot; &quot;median_weekly_earn&quot; colnames(earn) ## [1] &quot;sex&quot; &quot;race&quot; &quot;ethnic_origin&quot; ## [4] &quot;age&quot; &quot;year&quot; &quot;quarter&quot; ## [7] &quot;n_persons&quot; &quot;median_weekly_earn&quot; If the rows have names, you can get those with the rownames function. For this particular data set, the rows don’t have names. 1.6.1 Summarizing Data An efficient way to get a sense of what’s actually in a data set is to have R compute summary information. This works especially well for data frames, but also applies to other data. R provides two different functions to get summaries: str and summary. The str function returns a structural summary of an object. This kind of summary tells us about the structure of the data—the number of rows, the number and names of columns, what kind of data is in each column, and some sample values. Here’s the structural summary for the earnings data: str(earn) ## &#39;data.frame&#39;: 4224 obs. of 8 variables: ## $ sex : chr &quot;Both Sexes&quot; &quot;Both Sexes&quot; &quot;Both Sexes&quot; &quot;Both Sexes&quot; ... ## $ race : chr &quot;All Races&quot; &quot;All Races&quot; &quot;All Races&quot; &quot;All Races&quot; ... ## $ ethnic_origin : chr &quot;All Origins&quot; &quot;All Origins&quot; &quot;All Origins&quot; &quot;All Origins&quot; ... ## $ age : chr &quot;16 years and over&quot; &quot;16 years and over&quot; &quot;16 years and over&quot; &quot;16 years and over&quot; ... ## $ year : int 2010 2010 2010 2010 2011 2011 2011 2011 2012 2012 ... ## $ quarter : int 1 2 3 4 1 2 3 4 1 2 ... ## $ n_persons : int 96821000 99798000 101385000 100120000 98329000 100593000 101447000 101458000 100830000 102769000 ... ## $ median_weekly_earn: int 754 740 740 752 755 753 753 764 769 771 ... This summary lists information about each column, and includes most of what we found earlier by using several different functions separately. The summary uses chr to indicate columns of text (“characters”) and int to indicate columns of integers. In contrast to str, the summary function returns a statistical summary of an object. This summary includes summary statistics for each column, choosing appropriate statistics based on the kind of data in the column. For numbers, this is generally the mean, median, and quantiles. For categories, this is the frequencies. Other kinds of statistics are shown for other kinds of data. Here’s the statistical summary for the earnings data: summary(earn) ## sex race ethnic_origin age ## Length:4224 Length:4224 Length:4224 Length:4224 ## Class :character Class :character Class :character Class :character ## Mode :character Mode :character Mode :character Mode :character ## ## ## ## year quarter n_persons median_weekly_earn ## Min. :2010 Min. :1.00 Min. : 103000 Min. : 318.0 ## 1st Qu.:2012 1st Qu.:1.75 1st Qu.: 2614000 1st Qu.: 605.0 ## Median :2015 Median :2.50 Median : 7441000 Median : 755.0 ## Mean :2015 Mean :2.50 Mean : 16268338 Mean : 762.2 ## 3rd Qu.:2018 3rd Qu.:3.25 3rd Qu.: 17555250 3rd Qu.: 911.0 ## Max. :2020 Max. :4.00 Max. :118358000 Max. :1709.0 1.6.2 Selecting Columns You can select an individual column from a data frame by name with $, the dollar sign operator. The syntax is: VARIABLE$COLUMN_NAME For instance, for the earnings data, earn$age selects the age column, and earn$n_persons selects the n_persons column. So one way to compute the mean of the n_persons column is: mean(earn$n_persons) ## [1] 16268338 Similarly, to compute the range of the year column: range(earn$year) ## [1] 2010 2020 You can also use the dollar sign operator to assign values to columns. For instance, to assign 0 to the entire quarter column: earn$quarter = 0 Be careful when you do this, as there is no undo. Fortunately, we haven’t applied any transformations to the earnings data yet, so we can reset the earn variable back to what it was by reloading the data set: earn = read.csv(&quot;data/earn.csv&quot;) In Section 2.4, we’ll learn how to select rows and individual elements from a data frame, as well as other ways to select columns. 1.7 Exercises 1.7.1 Exercise In a string, an escape sequence or escape code consists of a backslash followed by one or more characters. Escape sequences make it possible to: Write quotes or backslashes within a string Write characters that don’t appear on your keyboard (for example, characters in a foreign language) For example, the escape sequence \\n corresponds to the newline character. There’s a complete list of escape sequences for R in the ?Quotes help file. Other programming languages also use escape sequences, and many of them are the same as in R. Assign a string that contains a newline to the variable newline. Then make R display the value of the variable by entering newline at the R prompt. The message function prints output to the R console, so it’s one way you can make your R code report information as it runs. Use the message function to print newline. How does the output from part 1 compare to the output from part 2? Why do you think they differ? 1.7.2 Exercise Choose a directory on your computer that you’re familiar with, such as one you created. Determine the path to the directory, then use list.files to display its contents. Do the files displayed match what you see in your system’s file browser? What does the all.files parameter of list.files do? Give an example. 1.7.3 Exercise The read.table function is another function for reading tabular data. Take a look at the help file for read.table. Recall that read.csv reads tabular data where the values are separated by commas, and read.delim reads tabular data where the values are separated by tabs. What value-separator does read.table expect by default? Is it possible to use read.table to read a CSV? Explain. If your answer is yes, show how to use read.table to load the employee earnings data from Section 1.5.1. "],["data-structures.html", "2 Data Structures 2.1 Vectors 2.2 Data Types &amp; Classes 2.3 Special Values 2.4 Indexing 2.5 Exercises", " 2 Data Structures The previous chapter introduced R and gave you enough background to do some simple computations on data sets. This chapter focuses on the foundational knowledge and skills you’ll need in order to use R effectively in the long term. Specifically, it begins with a deep dive into R’s various data structures and data types, then explains a variety of ways to get and set their elements. 2.1 Vectors A vector is a collection of values. Vectors are the fundamental unit of data in R, and you’ve already used them in the previous sections. For instance, each column in a data frame is a vector. So the quarter column in the earnings data from Section 1.6 is a vector. Take a look at it now. You can use head to avoid printing too much. Set the second argument to 10 so that exactly 10 values are printed: head(earn$quarter, 10) ## [1] 1 2 3 4 1 2 3 4 1 2 Like all vectors, this vector is ordered, which just means the values, or elements, have specific positions. The value of the 1st element is 1, the 2nd is 2, the 5th is also 1, and so on. Notice that the elements of this vector are all integers. This isn’t just a quirk of the earnings data set. In R, the elements of a vector must all be the same type of data (we say the elements are homogeneous). A vector can contain integers, decimal numbers, strings, or several other types of data, but not a mix these all at once. The other columns in the earnings data frame are also vectors. For instance, the age column is a vector of strings: head(earn$age) ## [1] &quot;16 years and over&quot; &quot;16 years and over&quot; &quot;16 years and over&quot; ## [4] &quot;16 years and over&quot; &quot;16 years and over&quot; &quot;16 years and over&quot; Vectors can contain any number of elements, including 0 or 1 element. Unlike mathematics, R does not distinguish between vectors and scalars (solitary values). So as far as R is concerned, a solitary value, like 3, is a vector with 1 element. You can check the length of a vector (and other objects) with the length function: length(3) ## [1] 1 length(&quot;hello&quot;) ## [1] 1 length(earn$age) ## [1] 4224 Since the last of these is a column from the data frame earn, the length is the same as the number of rows in earn. 2.1.1 Creating Vectors Sometimes you’ll want to create your own vectors. You can do this by concatenating several vectors together with the c function. It accepts any number of vector arguments, and combines them into a single vector: c(1, 2, 19, -3) ## [1] 1 2 19 -3 c(&quot;hi&quot;, &quot;hello&quot;) ## [1] &quot;hi&quot; &quot;hello&quot; c(1, 2, c(3, 4)) ## [1] 1 2 3 4 If the arguments you pass to the c function have different data types, R will attempt to convert them to a common data type that preserves the information: c(1, &quot;cool&quot;, 2.3) ## [1] &quot;1&quot; &quot;cool&quot; &quot;2.3&quot; Section 2.2.2 explains the rules for this conversion in more detail. The colon operator : creates vectors that contain sequences of integers. This is useful for creating “toy” data to test things on, and later we’ll see that it’s also important in several other contexts. Here are a few different sequences: 1:3 ## [1] 1 2 3 -3:5 ## [1] -3 -2 -1 0 1 2 3 4 5 10:1 ## [1] 10 9 8 7 6 5 4 3 2 1 Beware that both endpoints are included in the sequence, even in sequences like 1:0, and that the difference between elements is always -1 or 1. If you want more control over the generated sequence, use the seq function instead. 2.1.2 Indexing Vectors You can access individual elements of a vector with the indexing operator [ (also called the square bracket operator). The syntax is: VECTOR[INDEXES] Here INDEXES is a vector of positions of elements you want to get or set. For example, let’s make a vector with 5 elements and get the 2nd element: x = c(4, 8, 3, 2, 1) x[2] ## [1] 8 Now let’s get the 3rd and 1st element: x[c(3, 1)] ## [1] 3 4 You can use the indexing operator together with the assignment operator to assign elements of a vector: x[3] = 0 x ## [1] 4 8 0 2 1 Indexing is among the most frequently used operations in R, so take some time to try it out with few different vectors and indexes. We’ll revisit indexing in Section 2.4 to learn a lot more about it. 2.1.3 Vectorization Let’s look at what happens if we call a mathematical function, like sin, on a vector: x = c(1, 3, 0, pi) sin(x) ## [1] 8.414710e-01 1.411200e-01 0.000000e+00 1.224647e-16 This gives us the same result as if we had called the function separately on each element. That is, the result is the same as: c(sin(1), sin(3), sin(0), sin(pi)) ## [1] 8.414710e-01 1.411200e-01 0.000000e+00 1.224647e-16 Of course, the first version is much easier to type. Functions that take a vector argument and get applied element-by-element like this are said to be vectorized. Most functions in R are vectorized, especially math functions. Some examples include sin, cos, tan, log, exp, and sqrt. Functions that are not vectorized tend to be ones that combine or aggregate values in some way. For instance, the sum, mean, median, length, and class functions are not vectorized. A function can be vectorized across multiple arguments. This is easiest to understand in terms of the arithmetic operators. Let’s see what happens if we add two vectors together: x = c(1, 2, 3, 4) y = c(-1, 7, 10, -10) x + y ## [1] 0 9 13 -6 The elements are paired up and added according to their positions. The other arithmetic operators are also vectorized: x - y ## [1] 2 -5 -7 14 x * y ## [1] -1 14 30 -40 x / y ## [1] -1.0000000 0.2857143 0.3000000 -0.4000000 2.1.4 Recycling When a function is vectorized across multiple arguments, what happens if the vectors have different lengths? Whenever you think of a question like this as you’re learning R, the best way to find out is to create some toy data and test it yourself. Let’s try that now: x = c(1, 2, 3, 4) y = c(-1, 1) x + y ## [1] 0 3 2 5 The elements of the shorter vector are recycled to match the length of the longer vector. That is, after the second element, the elements of y are repeated to make a vector with the same length as x (because x is longer), and then vectorized addition is carried out as usual. Here’s what that looks like written down: 1 2 3 4 + -1 1 -1 1 ----------- 0 3 2 5 If the length of the longer vector is not a multiple of the length of the shorter vector, R issues a warning, but still returns the result. The warning as meant as a reminder, because unintended recycling is a common source of bugs: x = c(1, 2, 3, 4, 5) y = c(-1, 1) x + y ## Warning in x + y: longer object length is not a multiple of shorter object ## length ## [1] 0 3 2 5 4 Recycling might seem strange at first, but it’s convenient if you want to use a specific value (or pattern of values) with a vector. For instance, suppose you want to multiply all the elements of a vector by 2. Recycling makes this easy: 2 * c(1, 2, 3) ## [1] 2 4 6 When you use recycling, most of the time one of the arguments will be a scalar like this. 2.2 Data Types &amp; Classes Data can be categorized into different types based on sets of shared characteristics. For instance, statisticians tend to think about whether data are numeric or categorical: numeric continuous (real or complex numbers) discrete (integers) categorical nominal (categories with no ordering) ordinal (categories with some ordering) Of course, other types of data, like graphs (networks) and natural language (books, speech, and so on), are also possible. Categorizing data this way is useful for reasoning about which methods to apply to which data. In R, data objects are categorized in two different ways: The class of an R object describes what the object does, or the role that it plays. Sometimes objects can do more than one thing, so objects can have more than one class. The class function, which debuted in Section 1.6, returns the classes of its argument. The type of an R object describes what the object is. Technically, the type corresponds to how the object is stored in your computer’s memory. Each object has exactly one type. The typeof function returns the type of its argument. Of the two, classes tend to be more important than types. If you aren’t sure what an object is, checking its classes should be the first thing you do. The built-in classes you’ll use all the time correspond to vectors and lists (which we’ll learn more about in Section 2.2.1): Class Example Description logical TRUE, FALSE Logical (or Boolean) values integer -1L, 1L, 2L Integer numbers numeric -2.1, 7, 34.2 Real numbers complex 3-2i, -8+0i Complex numbers character \"hi\", \"YAY\" Text strings list list(TRUE, 1, \"hi\") Ordered collection of heterogeneous elements R doesn’t distinguish between scalars and vectors, so the class of a vector is the same as the class of its elements: class(&quot;hi&quot;) ## [1] &quot;character&quot; class(c(&quot;hello&quot;, &quot;hi&quot;)) ## [1] &quot;character&quot; In addition, for most vectors, the class and the type are the same: x = c(TRUE, FALSE) class(x) ## [1] &quot;logical&quot; typeof(x) ## [1] &quot;logical&quot; The exception to this rule is numeric vectors, which have type double for historical reasons: class(pi) ## [1] &quot;numeric&quot; typeof(pi) ## [1] &quot;double&quot; typeof(3) ## [1] &quot;double&quot; The word “double” here stands for double-precision floating point number, a standard way to represent real numbers on computers. By default, R assumes any numbers you enter in code are numeric, even if they’re integer-valued. The class integer also represents integer numbers, but it’s not used as often as numeric. A few functions, such as the sequence operator : and the length function, return integers. You can also force R to create an integer by adding the suffix L to a number, but there are no major drawbacks to using the double default: class(1:3) ## [1] &quot;integer&quot; class(3) ## [1] &quot;numeric&quot; class(3L) ## [1] &quot;integer&quot; Besides the classes for vectors and lists, there are several built-in classes that represent more sophisticated data structures: Class Description function Functions factor Categorical values matrix Two-dimensional ordered collection of homogeneous elements array Multi-dimensional ordered collection of homogeneous elements data.frame Data frames For these, the class is usually different from the type. We’ll learn more about most of these later on. 2.2.1 Lists A list is an ordered data structure where the elements can have different types (they are heterogeneous). This differs from a vector, where the elements all have to have the same type, as we saw in Section 2.1. The tradeoff is that most vectorized functions do not work with lists. You can make an ordinary list with the list function: x = list(1, c(&quot;hi&quot;, &quot;bye&quot;)) class(x) ## [1] &quot;list&quot; typeof(x) ## [1] &quot;list&quot; For ordinary lists, the type and the class are both list. In Section 2.4, we’ll learn how to get and set list elements, and in later sections we’ll learn more about when and why to use lists. You’ve already seen one list, the earnings data frame: class(earn) ## [1] &quot;data.frame&quot; typeof(earn) ## [1] &quot;list&quot; Under the hood, data frames are lists, and each column is a list element. Because the class is data.frame rather than list, R treats data frames differently from ordinary lists. This difference is apparent in how data frames are printed compared to ordinary lists. 2.2.2 Implicit Coercion R’s types fall into a natural hierarchy of expressiveness: Each type on the right is more expressive than the ones to its left. That is, with the convention that FALSE is 0 and TRUE is 1, we can represent any logical value as an integer. In turn, we can represent any integer as a double, and any double as a complex number. By writing the number out, we can also represent any complex number as a string. The point is that no information is lost as we follow the arrows from left to right along the types in the hierarchy. In fact, R will automatically and silently convert from types on the left to types on the right as needed. This is called implicit coercion. As an example, consider what happens if we add a logical value to a number: TRUE + 2 ## [1] 3 R automatically converts the TRUE to the numeric value 1, and then carries out the arithmetic as usual. We’ve already seen implicit coercion at work once before, when we learned the c function. Since the elements of a vector all have to have the same type, if you pass several different types to c, then R tries to use implicit coercion to make them the same: x = c(TRUE, &quot;hi&quot;, 1, 1+3i) class(x) ## [1] &quot;character&quot; x ## [1] &quot;TRUE&quot; &quot;hi&quot; &quot;1&quot; &quot;1+3i&quot; Implicit coercion is strictly one-way; it never occurs in the other direction. If you want to coerce a type on the right to one on the left, you can do it explicitly with one of the as.TYPE functions. For instance, the as.numeric (or as.double) function coerces to numeric: as.numeric(&quot;3.1&quot;) ## [1] 3.1 There are a few types that fall outside of the hierarchy entirely, like functions. Implicit coercion doesn’t apply to these. If you try to use these types where it doesn’t make sense to, R generally returns an error: sin + 3 ## Error in sin + 3: non-numeric argument to binary operator If you try to use these types as elements of a vector, you get back a list instead: x = c(1, 2, sum) class(x) ## [1] &quot;list&quot; Understanding how implicit coercion works will help you avoid bugs, and can also be a time-saver. For example, we can use implicit coercion to succinctly count how many elements of a vector satisfy a some condition: x = c(1, 3, -1, 10, -2, 3, 8, 2) condition = x &lt; 4 sum(condition) # or sum(x &lt; 4) ## [1] 6 If you still don’t quite understand how the code above works, try inspecting each variable. In general, inspecting each step or variable is a good strategy for understanding why a piece of code works (or doesn’t work!). Here the implicit coercion happens in the third line. 2.2.3 Matrices &amp; Arrays A matrix is the two-dimensional analogue of a vector. The elements, which are arranged into rows and columns, are ordered and homogeneous. You can create a matrix from a vector with the matrix function. By default, the columns are filled first: # A matrix with 2 rows and 3 columns: matrix(1:6, 2, 3) ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 The class of a matrix is always matrix, and the type matches the type of the elements: x = matrix(c(&quot;a&quot;, &quot;b&quot;, NA, &quot;c&quot;), 2, 2) x ## [,1] [,2] ## [1,] &quot;a&quot; NA ## [2,] &quot;b&quot; &quot;c&quot; class(x) ## [1] &quot;matrix&quot; &quot;array&quot; typeof(x) ## [1] &quot;character&quot; You can use the matrix multiplication operator %*% to multiply two matrices with compatible dimensions. An array is a further generalization of matrices to higher dimensions. You can create an array from a vector with the array function. The characteristics of arrays are almost identical to matrices, but the class of an array is always array. 2.2.4 Factors A feature is categorical if it measures a qualitative category. For example, the genres rock, blues, alternative, folk, pop are categories. R uses the class factor to represent categorical data. Visualizations and statistical models sometimes treat factors differently than other data types, so it’s important to make sure you have the right data type. If you’re ever unsure, remember that you can check the class of an object with the class function. When you load a data set, R usually can’t tell which features are categorical. That means identifying and converting the categorical features is up to you. For beginners, it can be difficult to understand whether a feature is categorical or not. The key is to think about whether you want to use the feature to divide the data into groups. For example, if we want to know how many songs are in the rock genre, we first need to divide the songs by genre, and then count the number of songs in each group (or at least the rock group). As a second example, months recorded as numbers can be categorical or not, depending on how you want to use them. You might want to treat them as categorical (for example, to compute max rainfall in each month) or you might want to treat them as numbers (for example, to compute the number of months time between two events). The bottom line is that you have to think about what you’ll be doing in the analysis. In some cases, you might treat a feature as categorical only for part of the analysis. Let’s think about which features are categorical in earnings data set. To refresh our memory of what’s in the data set, we can look at the structural summary: str(earn) ## &#39;data.frame&#39;: 4224 obs. of 8 variables: ## $ sex : chr &quot;Both Sexes&quot; &quot;Both Sexes&quot; &quot;Both Sexes&quot; &quot;Both Sexes&quot; ... ## $ race : chr &quot;All Races&quot; &quot;All Races&quot; &quot;All Races&quot; &quot;All Races&quot; ... ## $ ethnic_origin : chr &quot;All Origins&quot; &quot;All Origins&quot; &quot;All Origins&quot; &quot;All Origins&quot; ... ## $ age : chr &quot;16 years and over&quot; &quot;16 years and over&quot; &quot;16 years and over&quot; &quot;16 years and over&quot; ... ## $ year : int 2010 2010 2010 2010 2011 2011 2011 2011 2012 2012 ... ## $ quarter : int 1 2 3 4 1 2 3 4 1 2 ... ## $ n_persons : int 96821000 99798000 101385000 100120000 98329000 100593000 101447000 101458000 100830000 102769000 ... ## $ median_weekly_earn: int 754 740 740 752 755 753 753 764 769 771 ... The columns n_persons and median_weekly_earn are quantitative rather than categorical, since they measure quantities of people and dollars, respectively. The sex, race, ethnic_origin, and age columns are all categorical, since they are all qualitative measurements. We can see this better if we use the table function to compute frequencies for the values in the columns: table(earn$sex) ## ## Both Sexes Men Women ## 1408 1408 1408 table(earn$race) ## ## All Races Asian Black or African American ## 2244 660 660 ## White ## 660 table(earn$ethnic_origin) ## ## All Origins Hispanic or Latino ## 3564 660 table(earn$age) ## ## 16 to 19 years 16 to 24 years 16 years and over 20 to 24 years ## 132 660 660 132 ## 25 to 34 years 25 to 54 years 25 years and over 35 to 44 years ## 132 660 660 132 ## 45 to 54 years 55 to 64 years 55 years and over 65 years and over ## 132 132 660 132 Each column has only a few unique values, repeated many times. These are ideal for grouping the data. If age had been recorded as a number, rather than a range, it would probably be better to treat it as quantitative, since there would be far more unique values. Columns with many unique values don’t make good categorical features, because each group will only have a few elements! That leaves us with the year and quarter columns. It’s easy to imagine grouping the data by year or quarter, but these are also clearly numbers. These columns can be treated as quantitative or categorical data, depending on how we want to use them to analyze the data. Let’s convert the age column to a factor. To do this, use the factor function: age = factor(earn$age) head(age) ## [1] 16 years and over 16 years and over 16 years and over 16 years and over ## [5] 16 years and over 16 years and over ## 12 Levels: 16 to 19 years 16 to 24 years 16 years and over ... 65 years and over Notice that factors are printed differently than strings. The categories of a factor are called levels. You can list the levels with the levels function: levels(age) ## [1] &quot;16 to 19 years&quot; &quot;16 to 24 years&quot; &quot;16 years and over&quot; ## [4] &quot;20 to 24 years&quot; &quot;25 to 34 years&quot; &quot;25 to 54 years&quot; ## [7] &quot;25 years and over&quot; &quot;35 to 44 years&quot; &quot;45 to 54 years&quot; ## [10] &quot;55 to 64 years&quot; &quot;55 years and over&quot; &quot;65 years and over&quot; Factors remember all possible levels even if you take a subset: age[1:3] ## [1] 16 years and over 16 years and over 16 years and over ## 12 Levels: 16 to 19 years 16 to 24 years 16 years and over ... 65 years and over This is another way factors are different from strings. Factors “remember” all possible levels even if they aren’t present. This ensures that if you plot a factor, the missing levels will still be represented on the plot. You can make a factor forget levels that aren’t present with the droplevels function: droplevels(age[1:3]) ## [1] 16 years and over 16 years and over 16 years and over ## Levels: 16 years and over 2.3 Special Values R has four special values to represent missing or invalid data. 2.3.1 Missing Values The value NA, called the missing value, represents missing entries in a data set. It’s implied that the entries are missing due to how the data was collected, although there are exceptions. As an example, imagine the data came from a survey, and respondents chose not to answer some questions. In the data set, their answers for those questions can be recorded as NA. The missing value is a chameleon: it can be a logical, integer, numeric, complex, or character value. By default, the missing value is logical, and the other types occur through coercion (2.2.2): class(NA) ## [1] &quot;logical&quot; class(c(1, NA)) ## [1] &quot;numeric&quot; class(c(&quot;hi&quot;, NA, NA)) ## [1] &quot;character&quot; The missing value is also contagious: it represents an unknown quantity, so using it as an argument to a function usually produces another missing value. The idea is that if the inputs to a computation are unknown, generally so is the output: NA - 3 ## [1] NA mean(c(1, 2, NA)) ## [1] NA As a consequence, testing whether an object is equal to the missing value with == doesn’t return a meaningful result: 5 == NA ## [1] NA NA == NA ## [1] NA You can use the is.na function instead: is.na(5) ## [1] FALSE is.na(NA) ## [1] TRUE is.na(c(1, NA, 3)) ## [1] FALSE TRUE FALSE Missing values are a feature that sets R apart from most other programming languages. 2.3.2 Infinity The value Inf represents infinity, and can be numeric or complex. You’re most likely to encounter it as the result of certain computations: 13 / 0 ## [1] Inf class(Inf) ## [1] &quot;numeric&quot; You can use the is.infinite function to test whether a value is infinite: is.infinite(3) ## [1] FALSE is.infinite(c(-Inf, 0, Inf)) ## [1] TRUE FALSE TRUE 2.3.3 Not a Number The value NaN, called not a number, represents a quantity that’s undefined mathematically. For instance, dividing 0 by 0 is undefined: 0 / 0 ## [1] NaN class(NaN) ## [1] &quot;numeric&quot; Like Inf, NaN can be numeric or complex. You can use the is.nan function to test whether a value is NaN: is.nan(c(10.1, log(-1), 3)) ## Warning in log(-1): NaNs produced ## [1] FALSE TRUE FALSE 2.3.4 Null The value NULL represents a quantity that’s undefined in R. Most of the time, NULL indicates the absence of a result. For instance, vectors don’t have dimensions, so the dim function returns NULL for vectors: dim(c(1, 2)) ## NULL class(NULL) ## [1] &quot;NULL&quot; typeof(NULL) ## [1] &quot;NULL&quot; Unlike the other special values, NULL has its own unique type and class. You can use the is.null function to test whether a value is NULL: is.null(&quot;null&quot;) ## [1] FALSE is.null(NULL) ## [1] TRUE 2.4 Indexing The way to get and set elements of a data structure is by indexing. Sometimes this is also called subsetting or (element) extraction. Indexing is a fundamental operation in R, key to reasoning about how to solve problems with the language. We first saw indexing in Section 1.6, where we used $, the dollar sign operator, to get and set data frame columns. We saw indexing again in Section 2.1.2, where we used [, the indexing or square bracket operator, to get and set elements of vectors. The indexing operator [ is R’s primary operator for indexing. It works in four different ways, depending on the type of the index you use. These four ways to select elements are: All elements, with no index By position, with a numeric index By name, with a character index By condition, with a logical index Let’s examine each in more detail. We’ll use this vector as an example, to keep things concise: x = c(a = 10, b = 20, c = 30, d = 40, e = 50) x ## a b c d e ## 10 20 30 40 50 Even though we’re using a vector here, the indexing operator works with almost all data structures, including factors, lists, matrices, and data frames. We’ll look at unique behavior for some of these later on. 2.4.1 All Elements The first way to use [ to select elements is to leave the index blank. This selects all elements: x[] ## a b c d e ## 10 20 30 40 50 This way of indexing is rarely used for getting elements, since it’s the same as entering the variable name without the indexing operator. Instead, its main use is for setting elements. Suppose we want to set all the elements of x to 5. You might try writing this: x = 5 x ## [1] 5 Rather than setting each element to 5, this sets x to the scalar 5, which is not what we want. Let’s reset the vector and try again, this time using the indexing operator: x = c(a = 10, b = 20, c = 30, d = 40, e = 50) x[] = 5 x ## a b c d e ## 5 5 5 5 5 As you can see, now all the elements are 5. So the indexing operator is necessary to specify that we want to set the elements rather than the whole variable. Let’s reset x one more time, so that we can use it again in the next example: x = c(a = 10, b = 20, c = 30, d = 40, e = 50) 2.4.2 By Position The second way to use [ is to select elements by position. This happens when you use an integer or numeric index. We already saw the basics of this in Section 2.1.2. The positions of the elements in a vector (or other data structure) correspond to numbers starting from 1 for the first element. This way of indexing is frequently used together with the sequence operator : to get ranges of values. For instance, let’s get the 2nd through 4th elements of x: x[2:4] ## b c d ## 20 30 40 You can also use this way of indexing to set specific elements or ranges of elements. For example, let’s set the 3rd and 5th elements of x to 9 and 7, respectively: x[c(3, 5)] = c(9, 7) x ## a b c d e ## 10 20 9 40 7 When getting elements, you can repeat numbers in the index to get the same element more than once. You can also use the order of the numbers to control the order of the elements: x[c(2, 1, 2, 2)] ## b a b b ## 20 10 20 20 Finally, if the index contains only negative numbers, the elements at those positions are excluded rather than selected. For instance, let’s get all elements except the 1st and 5th: x[-c(1, 5)] ## b c d ## 20 9 40 When you index by position, the index should always be all positive or all negative. Using a mix of positive and negative numbers causes R to emit error rather than returning elements, since it’s unclear what the result should be: x[c(-1, 2)] ## Error in x[c(-1, 2)]: only 0&#39;s may be mixed with negative subscripts 2.4.3 By Name The third way to use [ is to select elements by name. This happens when you use a character vector as the index, and only works with named data structures. Like indexing by position, you can use indexing by name to get or set elements. You can also use it to repeat elements or change the order. Let’s get elements a, c, d, and a again from the vector x: y = x[c(&quot;a&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;)] y ## a c d a ## 10 9 40 10 Element names are generally unique, but if they’re not, indexing by name gets or sets the first element whose name matches the index: y[&quot;a&quot;] ## a ## 10 Let’s reset x again to prepare for learning about the final way to index: x = c(a = 10, b = 20, c = 30, d = 40, e = 50) 2.4.4 By Condition The fourth and final way to use [ is to select elements based on a condition. This happens when you use a logical vector as the index. The logical vector should have the same length as what you’re indexing, and will be recycled if it doesn’t. Congruent Vectors To understand indexing by condition, we first need to learn about congruent vectors. Two vectors are congruent if they have the same length and they correspond element-by-element. For example, suppose you do a survey that records each respondent’s favorite animal and age. These are two different vectors of information, but each person will have a response for both. So you’ll have two vectors that are the same length: animal = c(&quot;dog&quot;, &quot;cat&quot;, &quot;iguana&quot;) age = c(31, 24, 72) The 1st element of each vector corresponds to the 1st person, the 2nd to the 2nd person, and so on. These vectors are congruent. Notice that columns in a data frame are always congruent! Back to Indexing When you index by condition, the index should generally be congruent to the object you’re indexing. Elements where the index is TRUE are kept and elements where the index is FALSE are dropped. If you create the index from a condition on the object, it’s automatically congruent. For instance, let’s make a condition based on the vector x: is_small = x &lt; 25 is_small ## a b c d e ## TRUE TRUE FALSE FALSE FALSE The 1st element in the logical vector is_small corresponds to the 1st element of x, the 2nd to the 2nd, and so on. The vectors x and is_small are congruent. It makes sense to use is_small as an index for x, and it gives us all the elements less than 25: x[is_small] ## a b ## 10 20 Of course, you can also avoid using an intermediate variable for the condition: x[x &gt; 10] ## b c d e ## 20 30 40 50 If you create index some other way (not using the object), make sure that it’s still congruent to the object. Otherwise, the subset returned from indexing might not be meaningful. You can also use indexing by condition to set elements, just as the other ways of indexing can be used to set elements. For instance, let’s set all the elements of x that are greater than 10 to the missing value NA: x[x &gt; 10] = NA x ## a b c d e ## 10 NA NA NA NA 2.4.5 Logic All of the conditions we’ve seen so far have been written in terms of a single test. If you want to use more sophisticated conditions, R provides operators to negate and combine logical vectors. These operators are useful for working with logical vectors even outside the context of indexing. Negation The NOT operator ! converts TRUE to FALSE and FALSE to TRUE: x = c(TRUE, FALSE, TRUE, TRUE, NA) x ## [1] TRUE FALSE TRUE TRUE NA !x ## [1] FALSE TRUE FALSE FALSE NA You can use ! with a condition: y = c(&quot;hi&quot;, &quot;hello&quot;) !(y == &quot;hi&quot;) ## [1] FALSE TRUE The NOT operator is vectorized. Combinations R also has operators for combining logical values. The AND operator &amp; returns TRUE only when both arguments are TRUE. Here are some examples: FALSE &amp; FALSE ## [1] FALSE TRUE &amp; FALSE ## [1] FALSE FALSE &amp; TRUE ## [1] FALSE TRUE &amp; TRUE ## [1] TRUE c(TRUE, FALSE, TRUE) &amp; c(TRUE, TRUE, FALSE) ## [1] TRUE FALSE FALSE The OR operator | returns TRUE when at least one argument is TRUE. Let’s see some examples: FALSE | FALSE ## [1] FALSE TRUE | FALSE ## [1] TRUE FALSE | TRUE ## [1] TRUE TRUE | TRUE ## [1] TRUE c(TRUE, FALSE) | c(TRUE, TRUE) ## [1] TRUE TRUE Be careful: everyday English is less precise than logic. You might say: I want all subjects with age over 50 and all subjects that like cats. But in logic this means: (subject age over 50) OR (subject likes cats) So think carefully about whether you need both conditions to be true (AND) or at least one (OR). Rarely, you might want exactly one condition to be true. The XOR (eXclusive OR) function xor() returns TRUE when exactly one argument is TRUE. For example: xor(FALSE, FALSE) ## [1] FALSE xor(TRUE, FALSE) ## [1] TRUE xor(TRUE, TRUE) ## [1] FALSE The AND, OR, and XOR operators are vectorized. Short-circuiting The second argument is irrelevant in some conditions: FALSE &amp; is always FALSE TRUE | is always TRUE Now imagine you have FALSE &amp; long_computation(). You can save time by skipping long_computation(). A short-circuit operator does exactly that. R has two short-circuit operators: &amp;&amp; is a short-circuited &amp; || is a short-circuited | These operators only evaluate the second argument if it is necessary to determine the result. Here are some of these: TRUE &amp;&amp; FALSE ## [1] FALSE TRUE &amp;&amp; TRUE ## [1] TRUE TRUE || TRUE ## [1] TRUE c(TRUE, FALSE) &amp;&amp; c(TRUE, TRUE) ## Warning in c(TRUE, FALSE) &amp;&amp; c(TRUE, TRUE): &#39;length(x) = 2 &gt; 1&#39; in coercion to ## &#39;logical(1)&#39; ## Warning in c(TRUE, FALSE) &amp;&amp; c(TRUE, TRUE): &#39;length(x) = 2 &gt; 1&#39; in coercion to ## &#39;logical(1)&#39; ## [1] TRUE For the final expression, notice R only combines the first element of each vector. The others are ignored. In other words, the short-circuit operators are not vectorized! Because of this, generally you should not use the short-circuit operators for indexing. Their main use is in writing conditions for if-statements, which we’ll learn about later on. 2.5 Exercises 2.5.1 Exercise The rep function is another way to create a vector. Read the help file for the rep function. What does the rep function do to create a vector? Give an example. The rep function has parameters times and each. What does each do, and how do they differ? Give examples for both. Can you set both of times and each in a single call to rep? If the function raises an error, explain what the error message means. If the function returns a result, explain how the result corresponds to the arguments you chose. 2.5.2 Exercise Considering how implicit coercion works (Section 2.2.2): Why does \"3\" + 4 raise an error? Why does \"TRUE\" == TRUE return TRUE? Why does \"FALSE\" &lt; TRUE return TRUE? 2.5.3 Exercise Section 2.3.1 described the missing value as a “chameleon” because it can have many different types. Is Inf also a chameleon? Use examples to justify your answer. The missing value is also “contagious” because using it as an argument usually produces another missing value. Is Inf contagious? Again, use examples to justify your answer. 2.5.4 Exercise The table function is useful for counting all sorts of things, not just level frequencies for a factor. For instance, you can use table to count how many TRUE and FALSE values there are in a logical vector. For the earnings data, how many rows had median weekly earnings below $750? Based on how the data is structured, is your answer in part 1 the same as the number of quarters that had median weekly earnings below $750? Explain. "],["exploring-data.html", "3 Exploring Data 3.1 Indexing Data Frames 3.2 Packages 3.3 Data Visualization 3.4 Apply Functions 3.5 Exercises", " 3 Exploring Data Now that you have a solid foundation in the basic functions and data structures of R, you can move on to its most popular application: data analysis. In this chapter, you’ll learn how to efficiently explore and summarize data with visualizations and statistics. Along the way, you’ll also learn how to use apply functions, which are essential to fluency in R. 3.1 Indexing Data Frames This section explains how to get and set data in a data frame, expanding on the indexing techniques you learned in Section 2.4. Under the hood, every data frame is a list, so first you’ll learn about indexing lists. 3.1.1 Indexing Lists Lists are a container for other types of R objects. When you select an element from a list, you can either keep the container (the list) or discard it. The indexing operator [ almost always keeps containers. As an example, let’s get some elements from a small list: x = list(first = c(1, 2, 3), second = sin, third = c(&quot;hi&quot;, &quot;hello&quot;)) y = x[c(1, 3)] y ## $first ## [1] 1 2 3 ## ## $third ## [1] &quot;hi&quot; &quot;hello&quot; class(y) ## [1] &quot;list&quot; The result is still a list. Even if we get just one element, the result of indexing a list with [ is a list: class(x[1]) ## [1] &quot;list&quot; Sometimes this will be exactly what we want. But what if we want to get the first element of x so that we can use it in a vectorized function? Or in a function that only accepts numeric arguments? We need to somehow get the element and discard the container. The solution to this problem is the extraction operator [[, which is also called the double square bracket operator. The extraction operator is the primary way to get and set elements of lists and other containers. Unlike the indexing operator [, the extraction operator always discards the container: x[[1]] ## [1] 1 2 3 class(x[[1]]) ## [1] &quot;numeric&quot; The tradeoff is that the extraction operator can only get or set one element at a time. Note that the element can be a vector, as above. Because it can only get or set one element at a time, the extraction operator can only index by position or name. Blank and logical indexes are not allowed. The final difference between the index operator [ and the extraction operator [[ has to do with how they handle invalid indexes. The index operator [ returns NA for invalid vector elements, and NULL for invalid list elements: c(1, 2)[10] ## [1] NA x[10] ## $&lt;NA&gt; ## NULL On the other hand, the extraction operator [[ raises an error for invalid elements: x[[10]] ## Error in x[[10]]: subscript out of bounds The indexing operator [ and the extraction operator [[ both work with any data structure that has elements. However, you’ll generally use the indexing operator [ to index vectors, and the extraction operator [[ to index containers (such as lists). 3.1.2 Two-dimensional Indexing For two-dimensional objects, like matrices and data frames, you can pass the indexing operator [ or the extraction operator [[ a separate index for each dimension. The rows come first: DATA[ROWS, COLUMNS] For instance, let’s get the first 3 rows and all columns of the earnings data: earn[1:3, ] ## sex race ethnic_origin age year quarter n_persons ## 1 Both Sexes All Races All Origins 16 years and over 2010 1 96821000 ## 2 Both Sexes All Races All Origins 16 years and over 2010 2 99798000 ## 3 Both Sexes All Races All Origins 16 years and over 2010 3 101385000 ## median_weekly_earn ## 1 754 ## 2 740 ## 3 740 As we saw in Section 2.4.1, leaving an index blank means all elements. As another example, let’s get the 3rd and 5th row, and the 2nd and 4th column: earn[c(3, 5), c(2, 4)] ## race age ## 3 All Races 16 years and over ## 5 All Races 16 years and over Mixing several different ways of indexing is allowed. So for example, we can get the same above, but use column names instead of positions: earn[c(3, 5), c(&quot;race&quot;, &quot;age&quot;)] ## race age ## 3 All Races 16 years and over ## 5 All Races 16 years and over For data frames, it’s especially common to index the rows by condition and the columns by name. For instance, let’s get the sex, age, and n_persons columns for all rows that pertain to women: result = earn[earn$sex == &quot;Women&quot;, c(&quot;sex&quot;, &quot;age&quot;, &quot;n_persons&quot;)] head(result) ## sex age n_persons ## 89 Women 16 years and over 43794000 ## 90 Women 16 years and over 44562000 ## 91 Women 16 years and over 44912000 ## 92 Women 16 years and over 44620000 ## 93 Women 16 years and over 44077000 ## 94 Women 16 years and over 44539000 3.1.3 The drop Parameter If you use two-dimensional indexing with [ to select exactly one column, you get a vector: result = earn[1:3, 2] class(result) ## [1] &quot;character&quot; The container is dropped, even though the indexing operator [ usually keeps containers. This also occurs for matrices. You can control this behavior with the drop parameter: result = earn[1:3, 2, drop = FALSE] class(result) ## [1] &quot;data.frame&quot; The default is drop = TRUE. 3.2 Packages A package is a collection of functions for use in R. Packages usually include documentation, and can also contain examples, vignettes, and data sets. Most packages are developed by members of the R community, so quality varies. There are also a few packages that are built into R but provide extra features. We’ll use a package in Section 3.3, so we’re learning about them now. The Comprehensive R Archive Network, or CRAN, is the main place people publish packages. As of writing, there were 18,619 packages posted to CRAN. This number has been steadily increasing as R has grown in popularity. Packages span a wide variety of topics and disciplines. There are packages related to statistics, social sciences, geography, genetics, physics, biology, pharmacology, economics, agriculture, and more. The best way to find packages is to search online, but the CRAN website also provides “task views” if you want to browse popular packages related to a specific discipline. The install.packages function installs one or more packages from CRAN. Its first argument is the packages to install, as a character vector. When you run install.packages, R will ask you to choose which mirror to download the package from. A mirror is a web server that has the same set of files as some other server. Mirrors are used to make downloads faster and to provide redundancy so that if a server stops working, files are still available somewhere else. CRAN has dozens of mirrors; you should choose one that’s geographically nearby, since that usually produces the best download speeds. If you aren’t sure which mirror to choose, you can use the 0-Cloud mirror, which attempts to automatically choose a mirror near you. As an example, here’s the code to install the remotes package: install.packages(&quot;remotes&quot;) If you run the code above, you’ll be asked to select a mirror, and then see output that looks something like this: --- Please select a CRAN mirror for use in this session --- trying URL &#39;https://cloud.r-project.org/src/contrib/remotes_2.3.0.tar.gz&#39; Content type &#39;application/x-gzip&#39; length 148405 bytes (144 KB) ================================================== downloaded 144 KB * installing *source* package ‘remotes’ ... ** package ‘remotes’ successfully unpacked and MD5 sums checked ** using staged installation ** R ** inst ** byte-compile and prepare package for lazy loading ** help *** installing help indices ** building package indices ** installing vignettes ** testing if installed package can be loaded from temporary location ** testing if installed package can be loaded from final location ** testing if installed package keeps a record of temporary installation path * DONE (remotes) The downloaded source packages are in ‘/tmp/Rtmp8t6iGa/downloaded_packages’ R goes through a variety of steps to install a package, even installing other packages that the package depends on. You can tell that a package installation succeeded by the final line DONE. When a package installation fails, R prints an error message explaining the problem instead. Once a package is installed, it stays on your computer until you remove it or remove R. This means you only need to install each package once. However, most packages are periodically updated. You can reinstall a package using install.packages the same way as above to get the latest version. Alternatively, you can update all of the R packages you have installed at once by calling the update.packages function. Beware that this may take a long time if you have a lot of packages installed. The function to remove packages is remove.packages. Like install.packages, this function’s first argument is the packages to remove, as a character vector. If you want to see which packages are installed, you can use the installed.packages function. It does not require any arguments. It returns a matrix with one row for each package and columns that contain a variety of information. Here’s an example: packages = installed.packages() # Just print the version numbers for 10 packages. packages[1:10, &quot;Version&quot;] ## abind brio CodeDepends diffobj GGally ggplot2 ## &quot;1.4-5&quot; &quot;1.1.1&quot; &quot;0.6.6&quot; &quot;0.3.3&quot; &quot;2.1.2&quot; &quot;3.3.6&quot; ## httpuv lcap.sec2 lmerTest magick ## &quot;1.5.5&quot; &quot;0.1-1&quot; &quot;3.1-3&quot; &quot;2.7.3&quot; You’ll see a different set of packages, since you have a different computer. Before you can use the functions (or other resources) in an installed package, you must load the package with the library function. R doesn’t load packages automatically because each package you load uses memory and may conflict with other packages. Thus you should only load the packages you need for whatever it is that you want to do. When you restart R, the loaded packages are cleared and you must again load any packages you want to use. Let’s load the remotes package we installed earlier: library(&quot;remotes&quot;) The library function works with or without quotes around the package name, so you may also see people write things like library(remotes). We recommend using quotes to make it unambiguous that you are not referring to a variable. A handful of packages print out a message when loaded, but the vast majority do not. Thus you can assume the call to library was successful if nothing is printed. If something goes wrong while loading a package, R will print out an error message explaining the problem. Finally, not all R packages are published to CRAN. GitHub is another popular place to publish R packages, especially ones that are experimental or still in development. Unlike CRAN, GitHub is a general-purpose website for publishing code written in any programming language, so it contains much more than just R packages and is not specifically R-focused. The remotes package that we just installed and loaded provides functions to install packages from GitHub. It is generally better to install packages from CRAN when they are available there, since the versions on CRAN tend to be more stable and intended for a wide audience. However, if you want to install a package from GitHub, you can learn more about the remotes package by reading its online documentation. 3.3 Data Visualization There are three popular systems for creating visualizations in R: The base R functions (primarily the plot function) The lattice package The ggplot2 package These three systems are not interoperable! Consequently, it’s best to choose one to use exclusively. Compared to base R, both lattice and ggplot2 are better at handling grouped data and generally require less code to create a nice-looking visualization. The ggplot2 package is so popular that there are now knockoff packages for other data-science-oriented programming languages like Python and Julia. The package is also part of the Tidyverse, a popular collection of R packages designed to work well together. Because of these advantages, we’ll use ggplot2 for visualizations in this and all future lessons. ggplot2 has detailed documentation and also a cheatsheet. The “gg” in ggplot2 stands for grammar of graphics. The idea of a grammar of graphics is that visualizations can be built up in layers. In ggplot2, the three layers every plot must have are: Data Geometry Aesthetics There are also several optional layers. Here are a few: Layer Description scales Title, label, and axis value settings facets Side-by-side plots guides Axis and legend position settings annotations Shapes that are not mapped to data coordinates Coordinate systems (Cartesian, logarithmic, polar) As an example, let’s plot the earnings data. First, we need to load ggplot2. As always, if this is your first time using the package, you’ll have to install it. Then you can load the package: # install.packages(&quot;ggplot2&quot;) library(&quot;ggplot2&quot;) ## Registered S3 methods overwritten by &#39;tibble&#39;: ## method from ## format.tbl pillar ## print.tbl pillar What kind of plot should we make? It depends on what data we want the plot to show. Let’s make a line plot that shows median earnings for each quarter in 2019, with separate lines for men and women. Before plotting, we need to take a subset of the earnings that only contains information for 2019: earn19 = earn[earn$year == 2019, ] The data is also broken down across race, ethnic_origin, and age. Since we aren’t interested in these categories for the plot, we need to further subset the data: earn19 = earn19[earn19$race == &quot;All Races&quot; &amp; earn19$ethnic_origin == &quot;All Origins&quot; &amp; earn19$age == &quot;16 years and over&quot;, ] Now we’re ready to make the plot. 3.3.1 Layer 1: Data The data layer determines the data set used to make the plot. ggplot and most other Tidyverse packages are designed for working with tidy data frames. Tidy means: Each observation has its own row. Each feature has its own column. Each value has its own cell. Tidy data sets are convenient in general. A later lesson will cover how to make an untidy data set tidy. Until then, we’ll take it for granted that the data sets we work with are tidy. To set up the data layer, call the ggplot function on a data frame: ggplot(earn19) This returns a blank plot. We still need to add a few more layers. 3.3.2 Layer 2: Geometry The geometry layer determines the shape or appearance of the visual elements of the plot. In other words, the geometry layer determines what kind of plot to make: one with points, lines, boxes, or something else. There are many different geometries available in ggplot2. The package provides a function for each geometry, always prefixed with geom_. To add a geometry layer to the plot, choose the geom_ function you want and add it to the plot with the + operator: ggplot(earn19) + geom_line() ## Error in `check_required_aesthetics()`: ## ! geom_line requires the following missing aesthetics: x and y This returns an error message that we’re missing aesthetics x and y. We’ll learn more about aesthetics in the next section, but this error message is especially helpful: it tells us exactly what we’re missing. When you use a geometry you’re unfamiliar with, it can be helpful to run the code for just the data and geometry layer like this, to see exactly which aesthetics need to be set. As we’ll see later, it’s possible to add multiple geometries to a plot. 3.3.3 Layer 3: Aesthetics The aesthetic layer determines the relationship between the data and the geometry. Use the aesthetic layer to map features in the data to aesthetics (visual elements) of the geometry. The aes function creates an aesthetic layer. The syntax is: aes(AESTHETIC = FEATURE, ...) The names of the aesthetics depend on the geometry, but some common ones are x, y, color, fill, shape, and size. There is more information about and examples of aesthetic names in the documentation. For example, we want to put quarter on the x-axis and median_weekly_earn on the y-axis. We also want to use a separate line style for each sex category. So the aesthetic layer should be: aes(x = quarter, y = median_weekly_earn, linetype = sex) In the aes function, column names are never quoted. Unlike most layers, the aesthetic layer is not added to the plot with the + operator. Instead, you can pass the aesthetic layer as the second argument to the ggplot function: ggplot(earn19, aes(x = quarter, y = median_weekly_earn, linetype = sex)) + geom_line() If you want to set an aesthetic to a constant value, rather than one that’s data dependent, do so outside of the aesthetic layer. For instance, suppose we want to make the lines blue: ggplot(earn19, aes(x = quarter, y = median_weekly_earn, linetype = sex)) + geom_line(color = &quot;blue&quot;) If you set an aesthetic to a constant value inside of the aesthetic layer, the results you get might not be what you expect: ggplot(earn19, aes(x = quarter, y = median_weekly_earn, linetype = sex, color = &quot;blue&quot;)) + geom_line() 3.3.4 Layer 4: Scales The scales layer controls the title, axis labels, and axis scales of the plot. Most of the functions in the scales layer are prefixed with scale_, but not all of them. The labs function is especially important, because it’s used to set the title and axis labels: ggplot(earn19, aes(x = quarter, y = median_weekly_earn, linetype = sex)) + geom_line() + labs(x = &quot;Quarter&quot;, y = &quot;Median Weekly Salary (USD)&quot;, title = &quot;2019 Median Weekly Salaries, by Sex&quot;, linetype = &quot;Sex&quot;) 3.3.5 Saving Plots In ggplot2, use the ggsave function to save the most recent plot you created: ggsave(&quot;line.png&quot;) The file format is selected automatically based on the extension. Common formats are PNG and PDF. The Plot Device You can also save a plot with one of R’s “plot device” functions. The steps are: Call a plot device function: png, jpeg, pdf, bmp, tiff, or svg. Run your code to make the plot. Call dev.off to indicate that you’re done plotting. This strategy works with any of R’s graphics systems (not just ggplot2). Here’s an example: # Run these lines in the console, not the notebook! jpeg(&quot;line.jpeg&quot;) ggplot(favs, aes(x = distance_mi, y = walk_min)) + geom_point() dev.off() 3.3.6 Example: Bar Plot Let’s say we want to plot the number of persons for each sex, again using the earnings data set. A bar plot is an appropriate way to represent this visually. The geometry for a bar plot is geom_bar. Since bar plots are mainly used to display frequencies, the geom_bar function automatically computes frequencies when given mapped to a categorical feature. The n_persons feature is not categorical, so we don’t need geom_bar to compute frequencies. To prevent geom_bar from computing frequencies automatically, set stat = \"identity\". Here’s the code to make the bar plot: ggplot(earn19, aes(x = quarter, y = n_persons, fill = sex)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) + labs(x = &quot;Quarter&quot;, y = &quot;Number of Workers&quot;, fill = &quot;Sex&quot;, title = &quot;Number of Workers by Quarter and Sex in 2019&quot;) The setting position = \"dodge\" instructs geom_bar to put the bars side-by-side rather than stacking them. 3.3.7 Visualization Design Designing high-quality visualizations goes beyond just mastering which R functions to call. You also need to think carefully about what kind of data you have and what message you want to convey. This section provides a few guidelines. The first step in data visualization is choosing an appropriate kind of plot. Here are some suggestions (not rules): Feature 1 Feature 2 Plot categorical bar, dot categorical categorical bar, dot, mosaic numerical box, density, histogram numerical categorical box, density, ridge numerical numerical line, scatter, smooth scatter If you want to add a: 3rd numerical feature, use it to change point/line sizes. 3rd categorical feature, use it to change point/line styles. 4th categorical feature, use side-by-side plots. Once you’ve selected a plot, here are some rules you should almost always follow: Always add a title and axis labels. These should be in plain English, not variable names! Specify units after the axis label if the axis has units. For instance, “Height (ft)”. Don’t forget that many people are colorblind! Also, plots are often printed in black and white. Use point and line styles to distinguish groups; color is optional. Add a legend whenever you’ve used more than one point or line style. Always write a few sentences explaining what the plot reveals. Don’t describe the plot, because the reader can just look at it. Instead, explain what they can learn from the plot and point out important details that are easily overlooked. Sometimes points get plotted on top of each other. This is called overplotting. Plots with a lot of overplotting can be hard to read and can even misrepresent the data by hiding how many points are present. Use a two-dimensional density plot or jitter the points to deal with overplotting. For side-by-side plots, use the same axis scales for both plots so that comparing them is not deceptive. Visualization design is a deep topic, and whole books have been written about it. One resource where you can learn more is DataLab’s Principles of Data Visualization Workshop Reader. 3.4 Apply Functions Section 2.1.3 introduced vectorization, a convenient and efficient way to compute multiple results. That section also mentioned that some of R’s functions—the ones that summarize or aggregate data—are not vectorized. The class function is an example of a function that’s not vectorized. If we call the class function on the earnings data set, we get just one result for the data set as a whole: class(earn) ## [1] &quot;data.frame&quot; What if we want to get the class of each column? We can get the class for a single column by selecting the column with $, the dollar sign operator: class(earn$age) ## [1] &quot;character&quot; But what if we want the classes for all the columns? We could write a call to class for each column, but that would be tedious. When you’re working with a programming language, you should try to avoid tedium; there’s usually a better, more automated way. Section 2.2.1 pointed out that data frames are technically lists, where each column is one element. With that in mind, what we need here is a line of code that calls class on each element of the data frame. The idea is similar to vectorization, but since we have a list and a non-vectorized function, we have to do a bit more than just call class(earn). The lapply function calls, or applies, a function on each element of a list or vector. The syntax is: lapply(X, FUN, ...) The function FUN is called once for each element of X, with the element as the first argument. The ... is for additional arguments to FUN, which are held constant across all the elements. Let’s try this out with the earnings data and the class function: lapply(earn, class) ## $sex ## [1] &quot;character&quot; ## ## $race ## [1] &quot;character&quot; ## ## $ethnic_origin ## [1] &quot;character&quot; ## ## $age ## [1] &quot;character&quot; ## ## $year ## [1] &quot;integer&quot; ## ## $quarter ## [1] &quot;integer&quot; ## ## $n_persons ## [1] &quot;integer&quot; ## ## $median_weekly_earn ## [1] &quot;integer&quot; The result is similar to if the class function was vectorized. In fact, if we use a vector and a vectorized function with lapply, the result is nearly identical to the result from vectorization: x = c(1, 2, pi) sin(x) ## [1] 8.414710e-01 9.092974e-01 1.224647e-16 lapply(x, sin) ## [[1]] ## [1] 0.841471 ## ## [[2]] ## [1] 0.9092974 ## ## [[3]] ## [1] 1.224647e-16 The only difference is that the result from lapply is a list. In fact, the lapply function always returns a list with one element for each element of the input data. The “l” in lapply stands for “list”. The lapply function is one member of a family of functions called apply functions. All of the apply functions provide ways to apply a function repeatedly to different parts of a data structure. We’ll meet a few more apply functions soon. When you have a choice between using vectorization or an apply function, you should always choose vectorization. Vectorization is clearer—compare the two lines of code above—and it’s also significantly more efficient. In fact, vectorization is the most efficient way to call a function repeatedly in R. As we saw with the class function, there are some situations where vectorization is not possible. That’s when you should think about using an apply function. 3.4.1 The sapply Function The related sapply function calls a function on each element of a list or vector, and simplifies the result. That last part is the crucial difference compared to lapply. When results from the calls all have the same type and length, sapply returns a vector or matrix instead of a list. When the results have different types or lengths, the result is the same as for lapply. The “s” in sapply stands for “simplify”. For instance, if we use sapply to find the classes of the columns in the earnings data, we get a character vector: sapply(earn, class) ## sex race ethnic_origin age ## &quot;character&quot; &quot;character&quot; &quot;character&quot; &quot;character&quot; ## year quarter n_persons median_weekly_earn ## &quot;integer&quot; &quot;integer&quot; &quot;integer&quot; &quot;integer&quot; Likewise, if we use sapply to compute the sin values, we get a numeric vector, the same as from vectorization: sapply(x, sin) ## [1] 8.414710e-01 9.092974e-01 1.224647e-16 In spite of that, vectorization is still more efficient than sapply, so use vectorization instead when possible. Apply functions are incredibly useful for summarizing data. For example, suppose we want to compute the frequencies for all of the columns in the earnings data set that aren’t numeric. First, we need to identify the columns. One way to do this is with the is.numeric function. Despite the name, this function actually tests whether its argument is a real number, not whether it its argument is a numeric vector. In other words, it also returns true for integer values. We can use sapply to apply this function to all of the columns in the earnings data set: is_not_number = !sapply(earn, is.numeric) is_not_number ## sex race ethnic_origin age ## TRUE TRUE TRUE TRUE ## year quarter n_persons median_weekly_earn ## FALSE FALSE FALSE FALSE Is it worth using R code to identify the non-numeric columns? Since there are only 8 columns in the earnings data set, maybe not. But if the data set was larger, with say 100 columns, it definitely would be. In general, it’s a good habit to use R to do things rather than do them manually. You’ll get more practice programming, and your code will be more flexible if you want to adapt it to other data sets. Now that we know which columns are non-numeric, we can use the table function to compute frequencies. We only want to compute frequencies for those columns, so we need to subset the data: lapply(earn[, is_not_number], table) ## $sex ## ## Both Sexes Men Women ## 1408 1408 1408 ## ## $race ## ## All Races Asian Black or African American ## 2244 660 660 ## White ## 660 ## ## $ethnic_origin ## ## All Origins Hispanic or Latino ## 3564 660 ## ## $age ## ## 16 to 19 years 16 to 24 years 16 years and over 20 to 24 years ## 132 660 660 132 ## 25 to 34 years 25 to 54 years 25 years and over 35 to 44 years ## 132 660 660 132 ## 45 to 54 years 55 to 64 years 55 years and over 65 years and over ## 132 132 660 132 We use lapply rather than sapply for this step because the table for each column will have a different length (but try sapply and see what happens!). 3.4.2 The Split-Apply Pattern In a data set with categorical features, it’s often useful to compute something for each category. The lapply and sapply functions can compute something for each element of a data structure, but categories are not necessarily elements. For example, the earnings data set has three different categories in the sex column. If we want all of the rows in one category, one way to get them is by indexing: women = earn[earn$sex == &quot;Women&quot;, ] head(women) ## sex race ethnic_origin age year quarter n_persons ## 89 Women All Races All Origins 16 years and over 2010 1 43794000 ## 90 Women All Races All Origins 16 years and over 2010 2 44562000 ## 91 Women All Races All Origins 16 years and over 2010 3 44912000 ## 92 Women All Races All Origins 16 years and over 2010 4 44620000 ## 93 Women All Races All Origins 16 years and over 2011 1 44077000 ## 94 Women All Races All Origins 16 years and over 2011 2 44539000 ## median_weekly_earn ## 89 665 ## 90 672 ## 91 662 ## 92 679 ## 93 683 ## 94 689 To get all three categories, we’d have to do this three times. If we want to compute something for each category, say the mean of the n_persons column, we also have to repeat that computation three times. Here’s what it would look like for just the women category: mean(women$n_persons) ## [1] 10758771 If the categories were elements, we could avoid writing code to index each category, and just use the sapply (or lapply) function to apply the mean function to each. The split function splits a vector or data frame into groups based on a vector of categories. The first argument to split is the data, and the second argument is a congruent vector of categories. We can use split to elegantly compute means of n_persons broken down by sex. First, we split the data by category. Since we only want to compute on the n_persons column, we only split that column: by_sex = split(earn$n_persons, earn$sex) class(by_sex) ## [1] &quot;list&quot; names(by_sex) ## [1] &quot;Both Sexes&quot; &quot;Men&quot; &quot;Women&quot; The result from split is a list with one element for each category. The individual elements contain pieces of the original n_persons column: head(by_sex$Women) ## [1] 43794000 44562000 44912000 44620000 44077000 44539000 Since the categories are elements in the split data, now we can use sapply the same way we did in previous examples: sapply(by_sex, mean) ## Both Sexes Men Women ## 24402515 13643727 10758771 This two-step process is an R idiom called the split-apply pattern. First you use split to convert categories into list elements, then you use an apply function to compute something on each category. Any time you want to compute results by category, you should think of this pattern. The split-apply pattern is so useful that R provides the tapply function as a shortcut. The tapply function is equivalent to calling split and then sapply. Like split, the first argument is the data and the second argument is a congruent vector of categories. The third argument is a function to apply, like the function argument in sapply. We can use tapply to compute the n_persons means by sex for the earnings data: tapply(earn$n_persons, earn$sex, mean) ## Both Sexes Men Women ## 24402515 13643727 10758771 Notice that the result is identical to the one we computed before. The “t” in tapply stands for “table”, because the tapply function is a generalization of the table function. If you use length as the third argument to tapply, you get the same results as you would from using the table function on the category vector. The aggregate function is closely related to tapply. It computes the same results, but organizes them into a data frame with one row for each category. In some cases, this format is more convenient. The arguments are the same, except that the second argument must be a list or data frame rather than a vector. As an example, here’s the result of using aggregate to compute the n_persons means: aggregate(earn$n_persons, list(earn$sex), mean) ## Group.1 x ## 1 Both Sexes 24402515 ## 2 Men 13643727 ## 3 Women 10758771 The lapply, sapply, and tapply functions are the three most important functions in the family of apply functions, but there are many more. You can learn more about all of R’s apply functions by reading this StackOverflow post. 3.5 Exercises "],["automating-tasks.html", "4 Automating Tasks 4.1 Conditional Expressions 4.2 Functions 4.3 Loops 4.4 Planning for Iteration 4.5 Exercises", " 4 Automating Tasks By now, we’ve learned all of the basic skills necessary to explore a data set in R. This final chapter is a collection of different topics relevant to cleaning data sets before and during analysis. Some of them, like loops, also have other applications. 4.1 Conditional Expressions Sometimes you’ll need code to do different things, depending on a condition. If-statements provide a way to write conditional code. For example, suppose we want to greet one person differently from the others: name = &quot;Nick&quot; if (name == &quot;Nick&quot;) { # If name is Nick: message(&quot;We went down the TRUE branch&quot;) msg = &quot;Hi Nick, nice to see you again!&quot; } else { # Anything else: msg = &quot;Nice to meet you!&quot; } ## We went down the TRUE branch Indent code inside of the if-statement by 2 or 4 spaces. Indentation makes your code easier to read. The condition in an if-statement has to be a scalar: name = c(&quot;Nick&quot;, &quot;Susan&quot;) if (name == &quot;Nick&quot;) { msg = &quot;Hi Nick!&quot; } else { msg = &quot;Nice to meet you!&quot; } ## Error in if (name == &quot;Nick&quot;) {: the condition has length &gt; 1 You can chain together if-statements: name = &quot;Susan&quot; if (name == &quot;Nick&quot;) { msg = &quot;Hi Nick, nice to see you again!&quot; } else if (name == &quot;Peter&quot;) { msg = &quot;Go away Peter, I&#39;m busy!&quot; } else { msg = &quot;Nice to meet you!&quot; } msg ## [1] &quot;Nice to meet you!&quot; If-statements return the value of the last expression in the evaluated block: name = &quot;Tom&quot; msg = if (name == &quot;Nick&quot;) { &quot;Hi Nick, nice to see you again!&quot; } else { &quot;Nice to meet you!&quot; } msg ## [1] &quot;Nice to meet you!&quot; Curly braces { } are optional for single-line expressions: name = &quot;Nick&quot; msg = if (name == &quot;Nick&quot;) &quot;Hi Nick, nice to see you again!&quot; else &quot;Nice to meet you!&quot; msg ## [1] &quot;Hi Nick, nice to see you again!&quot; But you have to be careful if you don’t use them: # NO GOOD: msg = if (name == &quot;Nick&quot;) &quot;Hi Nick, nice to see you again!&quot; else &quot;Nice to meet you!&quot; ## Error: &lt;text&gt;:4:1: unexpected &#39;else&#39; ## 3: &quot;Hi Nick, nice to see you again!&quot; ## 4: else ## ^ The else block is optional: msg = &quot;Hi&quot; name = &quot;Tom&quot; if (name == &quot;Nick&quot;) msg = &quot;Hi Nick, nice to see you again!&quot; msg ## [1] &quot;Hi&quot; When there’s no else block, the value of the else block is NULL: name = &quot;Tom&quot; msg = if (name == &quot;Nick&quot;) &quot;Hi Nick, nice to see you again!&quot; msg ## NULL 4.2 Functions The main way to interact with R is by calling functions, which was first explained way back in Section 1.2.4. Since then, you’ve learned how to use many of R’s built-in functions. This section explains how you can write your own functions. To start, let’s briefly review what functions are, and some of the jargon associated with them. It’s useful to think of functions as factories: raw materials (inputs) go in, products (outputs) come out. We can also represent this visually: +-------+ -- in --&gt;| f |-- out --&gt; +-------+ Programmers use several specific terms to describe the parts and usage of functions: Parameters are placeholder variables for inputs. Arguments are the actual values assigned to the parameters in a call. The return value is the output. The body is the code inside. Calling a function means using a function to compute something. Almost every command in R is a function, even the arithmetic operators and the parentheses! You can view the body of a function by typing its name without trailing parentheses (in contrast to how you call functions). The body of a function is usually surrounded by curly braces {}, although they’re optional if the body only contains one line of code. Indenting code inside of curly braces by 2-4 spaces also helps make it visually distinct from other code. For example, let’s look at the body of the append function, which appends a value to the end of a list or vector: append ## function (x, values, after = length(x)) ## { ## lengx &lt;- length(x) ## if (!after) ## c(values, x) ## else if (after &gt;= lengx) ## c(x, values) ## else c(x[1L:after], values, x[(after + 1L):lengx]) ## } ## &lt;bytecode: 0x55adf0d7bc60&gt; ## &lt;environment: namespace:base&gt; Don’t worry if you can’t understand everything the append function’s code does yet. It will make more sense later on, after you’ve written a few functions of your own. Many of R’s built-in functions are not entirely written in R code. You can spot these by calls to the special .Primitive or .Internal functions in their code. For instance, the sum function is not written in R code: sum ## function (..., na.rm = FALSE) .Primitive(&quot;sum&quot;) The function keyword creates a new function. Here’s the syntax: function(parameter1, parameter2, ...) { # Your code goes here # The result goes here } A function can have any number of parameters, and will automatically return the value of the last line of its body. A function is a value, and like any other value, if you want to reuse it, you need to assign it to variable. Choosing descriptive variable names is a good habit. For functions, that means choosing a name that describes what the function does. It often makes sense to use verbs in function names. Let’s create a function that detects negative numbers. It should take a vector of numbers as input, compare them to zero, and then return the logical result from the comparison as output. Here’s the code to do that: is_negative = function(x) { x &lt; 0 } # Since this is a one-line function, the curly braces are optional: is_negative = function(x) x &lt; 0 The name of the function, is_negative, describes what the function does and includes a verb. The parameter x is the input. The return value is the result of x &lt; 0, since we put that expression on the last line. Any time you write a function, the first thing you should do afterwards is test that it actually works. Let’s try the is_negative function on a few test cases: x = c(5, -1, -2, 0, 3) is_negative(6) ## [1] FALSE is_negative(-1.1) ## [1] TRUE is_negative(x) ## [1] FALSE TRUE TRUE FALSE FALSE Notice that the parameter x inside the function is different from the variable x we created outside the function. We’ll learn more about this in Section 5.2, but for now just remember that parameters and variables inside of a function are separate from variables outside of a function. A default argument is an argument assigned to a parameter if no argument is assigned in the call to the function. You can use = to assign default arguments to parameters when you define a function with the function keyword. For example, let’s write a function that gets the largest values in a vector. We’ll make the number of values to get a parameter, with a default argument of 5. Here’s the code and some test cases: top = function(x, n = 5) { sorted = sort(x, decreasing = TRUE) head(sorted, n) } y = c(-6, 7, 10, 3, 1, 15, -2) top(y, 3) ## [1] 15 10 7 top(y) ## [1] 15 10 7 3 1 4.2.1 Returning Values We’ve already seen that a function will automatically return the value of its last line. The return keyword causes a function to return a result immediately, without running any subsequent code in its body. It only makes sense to use return from inside of an if-statement. If your function doesn’t have any if-statements, you don’t need to use return. For example, suppose we want the is_negative function to return NA if the argument isn’t a number. This is an ideal case to use return, since we skip the computation x &lt; 0 when the argument isn’t a number. Here’s the new version of the function, as well as a new test case: is_negative = function(x) { if (!is.numeric(x)) return (NA) # TRUE for negative numbers, FALSE otherwise x &lt; 0 } is_negative(&quot;hi&quot;) ## [1] NA It’s idiomatic to only use return when strictly necessary. A function returns one R object, but sometimes computations have multiple results. In that case, return the results in a vector, list, or other data structure. For example, let’s make a function that computes the mean and median for a vector. We’ll return the results in a named list, although we could also use a named vector: compute_mean_med = function(x) { m1 = mean(x) m2 = median(x) list(mean = m1, median = m2) } compute_mean_med(c(1, 2, 3, 1)) ## $mean ## [1] 1.75 ## ## $median ## [1] 1.5 The names make the result easier to understand for the caller of the function, although they certainly aren’t required here. 4.2.2 Planning Your Functions Before you write a function, it’s useful to go through several steps: Write down what you want to do, in detail. It can also help to draw a picture of what needs to happen. Check whether there’s already a built-in function. Search online and in the R documentation. Write the code to handle a simple case first. For data science problems, use a small dataset at this step. Let’s apply this in one final example: a function that detects leap years. A year is a leap year if either of these conditions is true: It is divisible by 4 and not 100 It is divisible by 400 That means the years 2004 and 2000 are leap years, but the year 2200 is not. Here’s the code and a few test cases: # If year is divisible by 4 and not 100 -&gt; leap # If year is divisible by 400 -&gt; leap year = 2004 is_leap = function(year) { if (year %% 4 == 0 &amp; year %% 100 != 0) { leap = TRUE } else if (year %% 400 == 0) { leap = TRUE } else { leap = FALSE } leap } is_leap(400) ## [1] TRUE is_leap(1997) ## [1] FALSE Functions are the building blocks for solving larger problems. Take a divide-and-conquer approach, breaking large problems into smaller steps. Use a short function for each step. This approach makes it easier to: Test that each step works correctly. Modify, reuse, or repurpose a step. 4.3 Loops One major benefit of using a programming language like R is that repetitive tasks can be automated. We’ve already seen two ways to do this: Vectorization, introduced in Section 2.1.3 Apply functions, introduced in Section 3.4 Both of these are iteration strategies. They iterate over some object, and compute something for each element. Each one of these computations is one iteration. Vectorization is the most efficient iteration strategy, but only works with vectorized functions and vectors. Apply functions are more flexible—they work with any function and any data structure with elements—but less efficient and less concise. A loop is another iteration strategy, one that’s even more flexible than apply functions. Besides being flexible, loops are a feature of almost all modern programming languages, so it’s useful to understand them. In R, there are two kinds of loops. We’ll learn both. 4.3.1 For-loops A for-loop runs a block of code once for each element of a vector or list. The for keyword creates a for-loop. Here’s the syntax: for (I in DATA) { # Your code goes here } The variable I is called the induction variable. At the beginning of each iteration, I is assigned the next element of the vector or list DATA. The loop iterates once for each element of DATA, unless you use a keyword to exit the loop early (more about this in Section 4.3.4). As with if-statements and functions, the curly braces { } are only required if the body contains multiple lines of code. Unlike the other iteration strategies, loops do not automatically return a result. You have complete control over the output, which means that anything you want to save must be assigned to a variable. For example, let’s make a loop that repeatedly adds a number to a running total and squares the new total. We’ll use a variable total to keep track of the running total as the loop iterates: numbers = c(-1, 1, -3, 2) total = 0 for (number in numbers) { total = (total + number)^2 } total ## [1] 9 Use for-loops when some or all of the iterations depend on results from other iterations. If the iterations are not dependent, use one of: Vectorization (because it’s faster) Apply functions (because they’re idiomatic) In some cases, you can use vectorization even when the iterations are dependent. For example, you can use vectorization to compute the sum of the cubes of several numbers: sum(numbers^3) ## [1] -19 4.3.2 While-loops A while-loop runs a block of code repeatedly as long as some condition is TRUE. The while keyword creates a while-loop. Here’s the syntax: while (CONDITION) { # Your code goes here } The CONDITION should be a scalar logical value or an expression that returns one. At the beginning of each iteration, CONDITION is checked, and the loop exits if it is FALSE. As always, the curly braces { } are only required if the body contains multiple lines of code. For example, suppose you want to add up numbers from 0 to 50, but stop as soon as the total is greater than 50: num50 = seq(0, 50) total = 0 i = 1 while (total &lt; 50) { total = total + num50[i] message(&quot;i is &quot;, i, &quot; total is &quot;, total) i = i + 1 } ## i is 1 total is 0 ## i is 2 total is 1 ## i is 3 total is 3 ## i is 4 total is 6 ## i is 5 total is 10 ## i is 6 total is 15 ## i is 7 total is 21 ## i is 8 total is 28 ## i is 9 total is 36 ## i is 10 total is 45 ## i is 11 total is 55 total ## [1] 55 i ## [1] 12 While-loops are a generalization of for-loops. They tend to be most useful when you don’t know how many iterations will be necessary. For example, suppose you want to repeat a computation until the result falls within some range of values. 4.3.3 Saving Multiple Results Loops often produce a different result for each iteration. If you want to save more than one result, there are a few things you must do. First, set up an index vector. The index vector should usually be congruent to the number of iterations or the input. The seq_along function returns a congruent index vector when passed a vector or list. For instance, let’s make in index for the numbers vector from Section 4.3.1: index = seq_along(numbers) The loop will iterate over the index rather than the input, so the induction variable will track the current iteration number. On the first iteration, the induction variable will be 1, on the second it will be 2, and so on. Then you can use the induction variable and indexing to get the input for each iteration. Second, set up an empty output vector or list. This should usually be congruent to the input, or one element longer (the extra element comes from the initial value). R has several functions for creating vectors. We’ve already seen a few, but here are more: logical, integer, numeric, complex, and character to create an empty vector with a specific type and length vector to create an empty vector with a specific type and length rep to create a vector by repeating elements of some other vector Empty vectors are filled with FALSE, 0, or \"\", depending on the type of the vector. Here are some examples: logical(3) ## [1] FALSE FALSE FALSE numeric(4) ## [1] 0 0 0 0 rep(c(1, 2), 2) ## [1] 1 2 1 2 Let’s create an empty numeric vector congruent to numbers: n = length(numbers) result = numeric(n) As with the input, you can use the induction variable and indexing to set the output for each iteration. Creating a vector or list in advance to store something, as we’ve just done, is called preallocation. Preallocation is extremely important for efficiency in loops. Avoid the temptation to use c or append to build up the output bit by bit in each iteration. Finally, write the loop, making sure to get the input and set the output. Here’s the loop for the squared sums example: for (i in index) { prev = if (i &gt; 1) result[i - 1] else 0 result[i] = (numbers[i] + prev)^2 } result ## [1] 1 4 1 9 4.3.4 Break &amp; Next The break keyword causes a loop to immediately exit. It only makes sense to use break inside of an if-statement. For example, suppose we want to print each string in a vector, but stop at the first missing value. We can do this with break: my_messages = c(&quot;Hi&quot;, &quot;Hello&quot;, NA, &quot;Goodbye&quot;) for (msg in my_messages) { if (is.na(msg)) break message(msg) } ## Hi ## Hello The next keyword causes a loop to immediately go to the next iteration. As with break, it only makes sense to use next inside of an if-statement. Let’s modify the previous example so that missing values are skipped, but don’t cause printing to stop. Here’s the code: for (msg in my_messages) { if (is.na(msg)) next message(msg) } ## Hi ## Hello ## Goodbye These keywords work with both for-loops and while-loops. 4.3.5 Example: Fibonacci As a final example, let’s use a loop to compute Fibonacci numbers. Each Fibonacci number is the sum of the previous two. The first few Fibonacci numbers are: 1 1 2 3 5 8 13 We can use a loop to compute the first n Fibonacci numbers. Make sure to choose an appropriate index and to preallocate for the output: n = 10 fib = c(1, 1, numeric(n - 2)) for (i in 3:n) { fib[i] = fib[i - 1] + fib[i - 2] } fib ## [1] 1 1 2 3 5 8 13 21 34 55 If you want to reuse this code, you could make it a function: fibonacci = function(n = 10) { fib = c(1, 1, numeric(n - 2)) for (i in 3:n) { fib[i] = fib[i - 1] + fib[i - 2] } fib } fibonacci(30) ## [1] 1 1 2 3 5 8 13 21 34 55 ## [11] 89 144 233 377 610 987 1597 2584 4181 6765 ## [21] 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 4.4 Planning for Iteration At first it may seem difficult to decide if and what kind of iteration to use. Start by thinking about whether you need to do something over and over. If you don’t, then you probably don’t need to use iteration. If you do, then try iteration strategies in this order: vectorization apply functions Try an apply function if iterations are independent. for/while-loops Try a for-loop if some iterations depend on others. Try a while-loop if the number of iterations is unknown. recursion (which isn’t covered here) Convenient for naturally recursive problems (like Fibonacci), but often there are faster solutions. Start by writing the code for just one iteration. Make sure that code works; it’s easy to test code for one iteration. When you have one iteration working, then try using the code with an iteration strategy (you will have to make some small changes). If it doesn’t work, try to figure out which iteration is causing the problem. One way to do this is to use message to print out information. Then try to write the code for the broken iteration, get that iteration working, and repeat this whole process. 4.5 Exercises "],["appendix.html", "5 Appendix 5.1 More Ways to Compare Values 5.2 Variable Scope &amp; Lookup 5.3 String Processing 5.4 Date Processing", " 5 Appendix 5.1 More Ways to Compare Values %in% for containment (explained below) Now let’s see what happens when we compare longer vectors: c(1, 2, 3) &lt; c(1, 3, -3) ## [1] FALSE TRUE FALSE c(&quot;he&quot;, &quot;saw&quot;, &quot;her&quot;) == c(&quot;she&quot;, &quot;saw&quot;, &quot;him&quot;) ## [1] FALSE TRUE FALSE Since the comparison operators are all vectorized, the elements of the vectors are compared element-by-element, and R returns a logical value for each pair. What if you want to test whether all the elements in a vector are equal (or unequal)? There are several ways to do this. One is to use the all function on the result of the comparison. The all function takes a vector of logical values and returns TRUE if all of them are TRUE, and returns FALSE otherwise: all(c(1, 2, 3) &lt; c(1, 3, -3)) ## [1] FALSE The related any function returns TRUE if any one element is TRUE, and returns FALSE otherwise: any(c(&quot;hi&quot;, &quot;hello&quot;) == c(&quot;hi&quot;, &quot;bye&quot;)) ## [1] TRUE There are two more ways to test whether objects are equal: The all.equal function tests whether objects are equal up to some acceptable difference called the tolerance. You should generally use all.equal rather than == to compare decimal numbers. Computer representations for decimal numbers are inherently imprecise, so comparison using a (small) tolerance is often necessary. The identical function checks whether objects are completely identical, including their metadata (names, dimensions, and so on). Use this to compare non-vector objects such as data frames. This function also works for vectors, but most of the time == is sufficient. Another common comparison is to check whether elements of one vector are contained in another vector at any position. For instance, suppose you want to check whether 1 or 2 appear anywhere in a longer vector x. Here’s how to do it: x = c(3, 4, 2, 7, 3, 7) c(1, 2) %in% x ## [1] FALSE TRUE R returns FALSE for the 1 because there’s no 1 in x, and returns TRUE for the 2 because there is a 2 in x. Notice that this is different from comparing with ==. If we use ==, the shorter vector is recycled until its length matches the longer one, and then compared element-by-element. For the example, this means only the elements at odd-numbered positions are compared to 1, and only the elements at even-numbered positions are compared to 2: c(1, 2) == x ## [1] FALSE FALSE FALSE FALSE FALSE FALSE Finally, new programmers sometimes incorrectly think they need to append == TRUE to their comparisons. This is redundant, makes your code harder to understand, and wastes computational time. Comparisons already return logical values. If the result of the comparison is TRUE, then TRUE == TRUE is again just TRUE. If the result is FALSE, then FALSE == TRUE is again just FALSE. Likewise, if you want to invert a condition, choose an appropriate operator rather than appending == FALSE. 5.2 Variable Scope &amp; Lookup 5.2.1 Local Variables A variable’s scope is the section of code where it exists and is accessible. The exists function checks whether a variable is in scope: exists(&quot;zz&quot;) ## [1] FALSE zz = 3 exists(&quot;zz&quot;) ## [1] TRUE When you create a function, you create a new scope. Variables defined inside of a function are local to the function. Local variables cannot be accessed from outside: rescale = function(x, center, scale) { centered = x - center centered / scale } centered ## Error in eval(expr, envir, enclos): object &#39;centered&#39; not found exists(&quot;centered&quot;) ## [1] FALSE Local variables are reset each time the function is called: f = function() { is_z_in_scope = exists(&quot;z&quot;) z = 42 is_z_in_scope } f() ## [1] FALSE f() ## [1] FALSE 5.2.2 Lexical Scoping A function can use variables defined outside (non-local), but only if those variables are in scope where the function was defined. This property is called lexical scoping. Let’s see how this works in practice. First, we’ll define a variable cats and then define a function get_cats in the same place (the top level, not inside any functions). As a result, the cats variable is in scope inside of the get_cats function: cats = 3 get_cats = function() cats get_cats() ## [1] 3 Now let’s define a variable dogs inside of a function create_dogs. We’ll also define a function get_dogs at the top level. The variable dogs is not in scope at the top level, so it’s not in scope inside of the get_dogs function: create_dogs = function() { dogs = &quot;hello&quot; } get_dogs = function() dogs create_dogs() get_dogs() ## Error in get_dogs(): object &#39;dogs&#39; not found Variables defined directly in the R console are global and available to any function. Local variables mask (hide) non-local variables with the same name: get_parrot = function() { parrot = 3 parrot } parrot = 42 get_parrot() ## [1] 3 There’s one exception to this rule. We often use variables that refer to functions in calls: #mean() In this case, the variable must refer to a function, so R ignores local variables that aren’t functions. For example: my_mean = function() { mean = 0 mean(c(1, 2, 3)) } my_mean() ## [1] 2 my_get_cats = function() { get_cats = 10 get_cats() } my_get_cats() ## [1] 3 5.2.3 Dynamic Lookup Variable lookup happens when a function is called, not when it’s defined. This is called dynamic lookup. For example, the result from get_cats, which accesses the global variable cats, changes if we change the value of cats: cats = 10 get_cats() ## [1] 10 cats = 20 get_cats() ## [1] 20 5.2.4 Summary This section covered a lot of details about R’s rules for variable scope and lookup. Here are the key takeaways: Function definitions (or local()) create a new scope. Local variables Are private Get reset for each call Mask non-local variables (exception: function calls) Lexical scoping: where a function is defined determines which non-local variables are in scope. Dynamic lookup: when a function is called determines values of non-local variables. 5.3 String Processing So far, we’ve mostly worked with numbers or categories that are ready to use for data analysis. In practice, data sets often require some cleaning before or during data analysis. One common data cleaning task is editing or extracting parts of strings. We’ll use the stringr package to process strings. Like ggplot2 (Section 3.3), the package is part of the Tidyverse. R also has built-in functions for string processing. The main advantage of stringr is that its functions use a common set of parameters, so they’re easier to learn and remember. stringr has detailed documentation and also a cheatsheet. The first time you use stringr, you’ll have to install it with install.packages (the same as any other package). Then you can load the package with the library function: # install.packages(&quot;stringr&quot;) library(&quot;stringr&quot;) The typical syntax of a stringr function is: str_NAME(string, pattern, ...) Where: NAME describes what the function does string is the string to search within or transform pattern is the pattern to search for ... is additional, function-specific arguments The str_detect function detects whether the pattern appears within the string. Here’s an example: str_detect(&quot;hello&quot;, &quot;el&quot;) ## [1] TRUE str_detect(&quot;hello&quot;, &quot;ol&quot;) ## [1] FALSE Most of the stringr functions are vectorized in the string parameter. For instance: str_detect(c(&quot;hello&quot;, &quot;goodbye&quot;, &quot;lo&quot;), &quot;lo&quot;) ## [1] TRUE FALSE TRUE Most of the stringr functions also have support for regular expressions, a powerful language for describing patterns. Several punctuation characters, such as . and ? have special meanings in the regular expressions language. You can disable these special meanings by putting the pattern in a call to fixed: str_detect(&quot;a&quot;, &quot;.&quot;) ## [1] TRUE str_detect(&quot;a&quot;, fixed(&quot;.&quot;)) ## [1] FALSE You can learn more about regular expressions here. There are a lot of stringr functions. We’ll focus on two that are especially important, and some of their variants: str_split str_replace You can find a complete list of stringr functions, with examples, in the documentation. 5.3.1 Splitting Strings The str_split function splits the string at each position that matches the pattern. The characters that match are thrown away. For example, suppose we want to split a sentence into words. Since there’s a space between each word, we can use a space as the pattern: x = &quot;The students in this workshop are great!&quot; result = str_split(x, &quot; &quot;) result ## [[1]] ## [1] &quot;The&quot; &quot;students&quot; &quot;in&quot; &quot;this&quot; &quot;workshop&quot; &quot;are&quot; &quot;great!&quot; The str_split function always returns a list with one element for each input string. Here the list only has one element because x only has one element. We can get the first element with: result[[1]] ## [1] &quot;The&quot; &quot;students&quot; &quot;in&quot; &quot;this&quot; &quot;workshop&quot; &quot;are&quot; &quot;great!&quot; We have to use the extraction operator [[ here because x is a list (for a vector, we could use the indexing operator [ instead). Notice that in the printout for result, R gives us a hint that we should use [[ by printing [[1]]. To see why the function returns a list, consider what happens if we try to split two different sentences at once: x = c(x, &quot;Are you listening?&quot;) result = str_split(x, &quot; &quot;) result[[1]] ## [1] &quot;The&quot; &quot;students&quot; &quot;in&quot; &quot;this&quot; &quot;workshop&quot; &quot;are&quot; &quot;great!&quot; result[[2]] ## [1] &quot;Are&quot; &quot;you&quot; &quot;listening?&quot; Each sentence has a different number of words, so the vectors in the result have different lengths. So a list is the only way to store both. The str_split_fixed function is almost the same as str_split, but takes a third argument for the maximum number of splits to make. Because the number of splits is fixed, the function can return the result in a matrix instead of a list. For example: str_split_fixed(x, &quot; &quot;, 3) ## [,1] [,2] [,3] ## [1,] &quot;The&quot; &quot;students&quot; &quot;in this workshop are great!&quot; ## [2,] &quot;Are&quot; &quot;you&quot; &quot;listening?&quot; The str_split_fixed function is often more convenient than str_split because the nth piece of each input string is just the nth column of the result. For example, suppose we want to get the area code from some phone numbers: phones = c(&quot;717-555-3421&quot;, &quot;629-555-8902&quot;, &quot;903-555-6781&quot;) result = str_split_fixed(phones, &quot;-&quot;, 3) result[, 1] ## [1] &quot;717&quot; &quot;629&quot; &quot;903&quot; 5.3.2 Replacing Parts of Strings The str_replace function replaces the pattern the first time it appears in the string. The replacement goes in the third argument. For instance, suppose we want to change the word \"dog\" to \"cat\": x = c(&quot;dogs are great, dogs are fun&quot;, &quot;dogs are fluffy&quot;) str_replace(x, &quot;dog&quot;, &quot;cat&quot;) ## [1] &quot;cats are great, dogs are fun&quot; &quot;cats are fluffy&quot; The str_replace_all function replaces the pattern every time it appears in the string: str_replace_all(x, &quot;dog&quot;, &quot;cat&quot;) ## [1] &quot;cats are great, cats are fun&quot; &quot;cats are fluffy&quot; We can also use the str_replace and str_replace_all functions to delete part of a string by setting the replacement to the empty string \"\". For example, suppose we want to delete the comma: str_replace(x, &quot;,&quot;, &quot;&quot;) ## [1] &quot;dogs are great dogs are fun&quot; &quot;dogs are fluffy&quot; In general, stringr functions with the _all suffix affect all matches. Functions without _all only affect the first match. 5.4 Date Processing Besides strings, dates and times are another kind of data that require special attention to prepare for analysis. This is especially important if you want to do anything that involves sorting dates, like making a line plot with dates on one axis. Dates may not be sorted correctly if they haven’t been converted to one of R’s date classes. There several built-in functions and also many packages for date processing. As with visualization and string processing, the Tidyverse packages have the best combination of simple design and clear documentation. There are three Tidyverse packages for processing dates and times: lubridate, the primary package for working with dates and times hms, a package specifically for working with times clock, a new package for working with dates and times We’ll focus on the lubridate package. As always, you’ll have to install the package if you haven’t already, and then load it: # install.packages(&quot;lubridate&quot;) library(&quot;lubridate&quot;) ## ## Attaching package: &#39;lubridate&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## date, intersect, setdiff, union The most common task is to convert a string into a date or time class. For instance, when you load a data set, you might have dates that look like this: dates = c(&quot;Jan 10, 2021&quot;, &quot;Sep 3, 2018&quot;, &quot;Feb 28, 1982&quot;) dates ## [1] &quot;Jan 10, 2021&quot; &quot;Sep 3, 2018&quot; &quot;Feb 28, 1982&quot; These are strings, so it’s relatively difficult to sort the dates, do arithmetic on them, or extract just one part (such as the year). There are several lubridate functions to automatically convert strings into dates. They are named with one letter for each part of the date. For instance, the dates in the example have the month (m), then the day (d), and then the year (y), so we can use the mdy function: result = mdy(dates) result ## [1] &quot;2021-01-10&quot; &quot;2018-09-03&quot; &quot;1982-02-28&quot; class(result) ## [1] &quot;Date&quot; Notice that the dates now have class Date, one of R’s built-in classes for representing dates, and that they print differently. You can find a full list of the automatic string to date conversion functions in the lubridate documentation. Occasionally, a date string may have a format that lubridate can’t convert automatically. In that case, you can use the fast_strptime function to describe the format in detail. At a minimum, the function requires two arguments: the vector of strings to convert and a format string. The format string describes the format of the dates, and is based on the syntax of strptime, a function provided by many programming languages for converting strings to dates (including R). In a format string, a percent sign % followed by a character is called a specification and has a special meaning. Here are a few of the most useful ones: Specification Description January 29, 2015 %Y 4-digit year 2015 %y 2-digit year 15 %m 2-digit month 01 %B full month name January %b short month name Jan %d day of month 29 %% literal % % You can find a complete list in ?fast_strptime. Other characters in the format string do not have any special meaning. Write the format string so that it matches the format of the dates you want to convert. For example, let’s try converting an unusual time format: odd_time = &quot;6 minutes, 32 seconds after 10 o&#39;clock&quot; fast_strptime(odd_time, &quot;%M minutes, %S seconds after %H o&#39;clock&quot;) ## [1] &quot;0-01-01 10:06:32 UTC&quot; R usually represents dates with the class Date, and date-times with the classes POSIXct and POSIXlt. The difference between the two date-time classes is somewhat technical, but you can read more about it in ?POSIXlt. There is no built-in class to represent times alone, which is why the result in the example above includes a date. Nonetheless, the hms package provides the hms class to represent times without dates. Once you’ve converted a string to a date, the lubridate package provides a variety of functions to get or set the parts individually. Here are a few examples: day(result) ## [1] 10 3 28 month(result) ## [1] 1 9 2 You can find a complete list in the lubridate documentation. "],["where-to-learn-more.html", "Where to Learn More", " Where to Learn More This reader provides an introduction to the basics of R, but there’s lots more to learn. Fortunately, many R and data science learning resources are available for free online or through the library. Here are a few readers and notes created by DataLab staff: README, Write Me!, our workshop about how to organize and document computing projects. Principles of Data Visualization, our workshop about how to design clear and effective data visualizations. Adventures in Data Science, our course introducing humanities undergraduates to data science techniques. My personal teaching notes from several years of teaching statistical computing. And here are a few books created by others that we’ve found useful: R for Data Science by Wickham &amp; Grolemund. An introduction to using R for data science, but with a very heavy focus on Tidyverse packages. The Art of R Programming by Matloff. A general reference on R programming. Advanced R by Wickham. A description of how R works at a deeper level, with many examples of R features that are important for package/software development. The R Inferno by Burns. A discussion of the most difficult and confusing parts of R. Finally, here are some websites popular in the R community: R Graph Gallery. Examples of graphs you can make in R, with code. RStudio Cheat Sheets. Cheat sheets for a variety of R tools and packages. R Weekly. Weekly updates about what’s happening in the R community. R-bloggers. An aggregator for blog posts about R. "],["acknowledgements.html", "Acknowledgements", " Acknowledgements Sincere thanks to: Duncan Temple Lang, whose guidance and encouragement has had outsize influence on the way I think about and teach data science. Deb Nolan, for being a role model as a data scientist, educator, and academic. Special thanks for the opportunity to collaborate on STAT 33 (on which this reader and workshop is loosely based) at Cal. The rest of the DataLab team, for support and many thoughtful discussions about data science: Wesley Brooks Glenda Gaines Jared Joseph Arthur Koehl Oliver Kreylos Pamela Reynolds Tyler Shoemaker Carl Stahmer Michele Tobias Last but not least, every former student that asked questions or offered feedback when I taught. "],["assessment.html", "Assessment", " Assessment The assessment will be posted by Sep 19, 2022. "]]
